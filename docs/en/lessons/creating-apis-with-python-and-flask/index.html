<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="description" content="" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		

		

		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="modulepreload" href="/_app/start-a80c730b.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-9b9d6288.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-de46afb2.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/__layout.svelte-e75718c6.js">
		<link rel="modulepreload" href="/_app/chunks/stores-191d1505.js">
		<link rel="modulepreload" href="/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js">

		<script type="module">
			import { start } from "/_app/start-a80c730b.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-de46afb2.js"),
						import("/_app/pages/_lang_/__layout.svelte-e75718c6.js"),
						import("/_app/pages/_lang_/_lessons_/_slug_/index.svelte-efe77d76.js")
					],
					url: new URL("sveltekit://prerender/en/lessons/creating-apis-with-python-and-flask"),
					params: {lang:"en",lessons:"lessons",slug:"creating-apis-with-python-and-flask"}
				}
			});
		</script><script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('/service-worker.js');
			}
		</script>
	</head>
	<body>
		<div id="svelte">


The Programming Historian <a href="/en">English</a> <a href="/es">Spanish</a>
<br>
This is the en edition.

<h1>Creating Web APIs with Python and Flask
</h1>

<!-- HTML_TAG_START --><p>{% include toc.html %}</p>
<h1 id="lesson-goals">Lesson Goals</h1>
<p>Web APIs are tools for making information and application functionality accessible over the internet. In this lesson, you will:</p>
<ul>
<li>Learn what an API is and when you should use one.</li>
<li>Learn how to build a web API that returns data to its users.</li>
<li>Learn some principles of good API design, applying them to an API that draws book metadata from a database.</li>
</ul>
<h1 id="setting-up">Setting Up</h1>
<h2 id="prerequisites">Prerequisites</h2>
<p>You can use the Windows, macOS, or Linux operating systems to complete this tutorial, and those few instructions that are not the same across platforms will be explicitly noted. Python 3, the Flask web framework, and a web browser are required for this tutorial, and installation instructions for all platforms are outlined below.</p>
<p>The only knowledge explicitly assumed for this lesson is the ability to use a text editor, such as BBEdit on macOS or Notepad++ on Windows. However, knowledge of the command line, Python, and web concepts such as HTTP may make this tutorial easier to follow. If you&#39;re new to Python, consider working through the Programming Historian series on <a href="/lessons/introduction-and-installation">dealing with online sources</a> to familiarize yourself with fundamental concepts in Python programming.</p>
<h2 id="installing-python-and-flask">Installing Python and Flask</h2>
<p>For this tutorial, you will need Python 3 and the Flask web framework. You&#39;ll also require a web browser (such as Firefox) and a text editor (such as Notepad++ or BBEdit).</p>
<p>To download Python, follow <a href="https://www.python.org/downloads/">this link</a>, select the button that says <code>Download Python 3.x.x</code>, and then run the installer as you normally would to install applications on your operating system. The default settings should be fine.</p>
<p>To confirm that Python installed successfully, first open the command line. In macOS, click the spotlight icon on the top right corner of your desktop (the magnifying glass) and type terminal. The terminal should be the first application that appears. On Windows, click the Start menu icon and type <code>cmd</code> in the search box, then press <code>Enter</code>.</p>
<p>Once your command line is open, enter these commands:</p>
<pre><code>python --version
pip --version
</code></pre>
<p>If the output for these commands includes a version number, Python is installed and available from the command line and you can proceed to the next step.</p>
<p>Next, you&#39;ll need to install Flask. At the command line, type</p>
<pre><code>pip install flask
</code></pre>
<p>This will install Flask using the pip package manager for Python. You should see some output ending in a notification that Flask has been installed successfully.</p>
<p>As an alternative to the above installation instructions, you can install the Python 3 version of Anaconda, which can be downloaded <a href="https://www.continuum.io">here</a>. Anaconda comes with Flask, so if you go this route you will not need to install Flask using the pip package manager.</p>
<p>If you&#39;re running into trouble installing Python, you may find <a href="/lessons/introduction-and-installation">this Programming Historian article on installing Python</a> helpful. Note that the instructions in that tutorial are for installing Python 2—make sure you choose Python 3 when downloading installers from the Python website, since this tutorial uses Python 3.</p>
<p>If you don&#39;t have a preferred text editor, I recommend <a href="https://www.barebones.com/products/bbedit/download.html">BBEdit</a> for macOS or <a href="https://notepad-plus-plus.org/">Notepad++</a> for Windows.</p>
<h1 id="introducing-apis">Introducing APIs</h1>
<h2 id="what-is-an-api">What is an API?</h2>
<p>If you&#39;ve heard the term API before, chances are it&#39;s been used not to refer to APIs in general, but instead to a specific kind of API, the web API. A web API allows for information or functionality to be manipulated by other programs via the internet. For example, with Twitter&#39;s web API, you can write a program in a language like Python or Javascript that can perform tasks such as favoriting tweets or collecting tweet metadata.</p>
<p>In programming more generally, the term API, short for Application Programming Interface, refers to a part of a computer program designed to be used or manipulated by another program, as opposed to an interface designed to be used or manipulated by a human. Computer programs frequently need to communicate amongst themselves or with the underlying operating system, and APIs are one way they do it. In this tutorial, however, we&#39;ll be using the term API to refer specifically to web APIs.</p>
<h2 id="when-to-create-an-api">When to Create an API</h2>
<p>In general, consider an API if:</p>
<ol>
<li>Your data set is large, making download via FTP unwieldy or resource-intensive.</li>
<li>Your users will need to access your data in real time, such as for display on another website or as part of an application.</li>
<li>Your data changes or is updated frequently.</li>
<li>Your users only need access to a part of the data at any one time.</li>
<li>Your users will need to perform actions other than retrieve data, such as contributing, updating, or deleting data.</li>
</ol>
<p>If you have data you wish to share with the world, an API is one way you can get it into the hands of others. However, APIs are not always the best way of sharing data with users. If the size of the data you are providing is relatively small, you can instead provide a &quot;data dump&quot; in the form of a downloadable JSON, XML, CSV, or SQLite file. Depending on your resources, this approach can be viable up to a download size of a few gigabytes.</p>
<p>Remember that you can provide both a data dump and an API, and individual users may find one or the other to better match their use case. <a href="https://openlibrary.org/">Open Library</a>, for example, provides both <a href="https://openlibrary.org/developers/dumps">a data dump</a> and <a href="https://openlibrary.org/developers/api">an API</a>, each of which serves different use cases for different users.</p>
<h2 id="api-terminology">API Terminology</h2>
<p>When using or building APIs, you will encounter these terms frequently:</p>
<ul>
<li><strong>HTTP (Hypertext Transfer Protocol)</strong> is the primary means of communicating data on the web. HTTP implements a number of &quot;methods,&quot; which tell which direction data is moving and what should happen to it. The two most common are GET, which pulls data from a server, and POST, which pushes new data to a server.</li>
<li><strong>URL (Uniform Resource Locator)</strong> - An address for a resource on the web, such as <code>https://programminghistorian.org/about</code>. A URL consists of a <strong>protocol</strong> (<code>http://</code>), domain (<code>programminghistorian.org</code>), and optional <strong>path</strong> (<code>/about</code>). A URL describes the location of a specific resource, such as a web page. When reading about APIs, you may see the terms <code>URL</code>, <code>request</code>, <code>URI</code>, or <code>endpoint</code> used to describe adjacent ideas. This tutorial will prefer the terms URL and request to avoid complication. You can follow a URL or make a GET request in your browser, so you won&#39;t need any special software to make requests in this tutorial.</li>
<li><strong>JSON (JavaScript Object Notation)</strong> is a text-based data storage format that is designed to be easy to read for both humans and machines. JSON is generally the most common format for returning data through an API, XML being the second most common.</li>
<li><strong>REST (REpresentational State Transfer)</strong> is a philosophy that describes some best practices for implementing APIs. APIs designed with some or all of these principles in mind are called REST APIs. While the API outlined in this lesson uses some REST principles, there is a great deal of disagreement around this term. For this reason, I do not describe the example APIs here as REST APIs, but instead as web or HTTP APIs.</li>
</ul>
<h1 id="using-apis">Using APIs</h1>
<h2 id="why-use-apis-as-a-researcher">Why Use APIs as a Researcher?</h2>
<p>The primary focus of this lesson is on creating an API, not exploring or using an API that has already been implemented. However, before we start building our own API, it may be useful to discuss how APIs are useful for researchers. In this section, we&#39;ll see how APIs can be useful for approaching historical, textual, or sociological questions using a &quot;macroscopic&quot; or &quot;distant reading&quot; approach that makes use of relatively large amounts of information. In doing so, we&#39;ll familiarize ourselves with the basic elements of a good API. Considering APIs from the perspective of a user will come in useful when we begin to design our own API later in the lesson.</p>
<h2 id="an-api-case-study-sensationalism-and-historical-fires">An API Case Study: Sensationalism and Historical Fires</h2>
<p>Imagine that our research area is sensationalism and the press: has newspaper coverage of major events in the United States become more or less sensational over time? Narrowing the topic, we might ask whether press coverage of, for example, urban fires has increased or decreased with government reporting on fire-related relief spending.</p>
<p>While we won&#39;t be able to explore this question thoroughly, we can begin to approach this research space by collecting historical data on newspaper coverage of fires using an API—in this case, the <a href="http://chroniclingamerica.loc.gov/about/api/">Chronicling America Historical Newspaper API</a>. The Chronicling America API allows access to metadata and text for millions of scanned newspaper pages. In addition, unlike many other APIs, it also does not require an authentication process, allowing us to immediately explore the available data without signing up for an account.</p>
<p>Our initial goal in approaching this research question is to find all newspaper stories in the Chronicling America database that use the term &quot;fire.&quot; Typically, use of an API starts with its documentation. On the <a href="http://chroniclingamerica.loc.gov/about/api/">Chronicling America API page</a>, we find two pieces of information critical for getting the data we want from the API: the API&#39;s <strong>base URL</strong> and the <strong>path</strong> corresponding to the function we want to perform on the API—in this case, searching the database.</p>
<p>Our base URL is:</p>
<pre><code>http://chroniclingamerica.loc.gov
</code></pre>
<p>All requests we make to the API must begin with this portion of the URL. All APIs have a base URL like this one that is the same across all requests to the API.</p>
<p>Our path is:</p>
<pre><code>/search/pages/results/
</code></pre>
<p>If we combine the base URL and the path together into one URL, we&#39;ll have created a request to the Chronicling America API that returns all available data in the database:</p>
<pre><code>http://chroniclingamerica.loc.gov/search/pages/results/
</code></pre>
<p>If you <a href="http://chroniclingamerica.loc.gov/search/pages/results/">visit the link above</a>, you&#39;ll see all items available in Chronicling America (12,243,633 at the time of writing), , not just the entries related to our search term, &quot;fire.&quot; This request also returns a formatted HTML view, rather than the structured view we want to use to collect data.</p>
<p>According to the Chronicling America documentation, in order to get structured data specifically relating to fire, we need to pass one more kind of data in our request: <strong>query parameters</strong>.</p>
<pre><code>http://chroniclingamerica.loc.gov/search/pages/results/?format=json&amp;proxtext=fire
</code></pre>
<p>The query parameters follow the <code>?</code> in the request, and are seperated from one another by the <code>&amp;</code> symbol. The first query parameter, <code>format=json</code>, changes the returned data from HTML to JSON. The second, <code>proxtext=fire</code>, narrows the returned entries to those that include our search term.</p>
<p>If you <a href="http://chroniclingamerica.loc.gov/search/pages/results/?format=json&amp;proxtext=fire">follow the above link</a> in your browser, you&#39;ll see a structured list of the items in the database related to the search term &quot;fire.&quot; The format of the returned data is called JSON, and is a structured format that looks like this excerpt from the Chronicling America results:</p>
<pre><code class="language-json">&quot;city&quot;: [
        &quot;Washington&quot;
      ],
      &quot;date&quot;: &quot;19220730&quot;,
      &quot;title&quot;: &quot;The Washington Herald.&quot;,
      &quot;end_year&quot;: 1939,
</code></pre>
<p>By making requests to the Chronicling America API, we&#39;ve accessed information on news stories that contain the search term &quot;fire,&quot; and returned data that includes the date of publication and the page the article appears on. If we were to pursue this research question further, a next step might be finding how many stories relating to fire appear on a newspaper&#39;s front page over time, or perhaps cleaning the data to reduce the number of false positives. As we have seen, however, exploring an API can be a useful first step in gathering data to tackle a research question.</p>
<div class="alert alert-warning">
Note that in this section, we skipped an important step: finding an appropriate API in the first place. Some resources for researching APIs are available at the end of this lesson.
</div>

<h2 id="what-users-want-in-an-api">What Users Want in an API</h2>
<p>As we&#39;ve learned, documentation is a user&#39;s starting place when working with a new API, and well-designed URLs make it easier for users to intuitively find resources. Because they help users to quickly access information through your API, these elements—documentation and well-conceived URLs—are the <em>sine qua non</em> of a good API. We&#39;ll discuss these elements in greater depth later in this tutorial.</p>
<p>As you use other APIs in your research, you&#39;ll develop a sense of what makes a good API from the perspective of a potential user. Just as strong readers often make strong writers, using APIs created by others and critically evaluating their implementation and documentation will help you better design your own APIs.</p>
<h1 id="implementing-our-api">Implementing Our API</h1>
<h2 id="overview">Overview</h2>
<p>This section will show you how to build a prototype API using Python and the Flask web framework. Our example API will take the form of a distant reading archive—a book catalog that goes beyond standard bibliographic information to include data of interest to those working on digital projects. In this case, besides title and date of publication, our API will also serve the first sentence of each book. This should be enough data to allow us to envision some potential research questions without overwhelming us as we focus on the design of our API.</p>
<p>We&#39;ll begin by using Flask to create a home page for our site. In this step, we&#39;ll learn the basics of how Flask works and make sure our software is configured correctly. Once we have a small Flask application working in the form of a home page, we&#39;ll iterate on this site, turning it into a functioning API.</p>
<h2 id="creating-a-basic-flask-application">Creating a Basic Flask Application</h2>
<p><a href="http://flask.pocoo.org/">Flask</a> is a web framework for Python, meaning that it provides functionality for building web applications, including managing HTTP requests and rendering templates. In this section, we will create a basic Flask application. In later sections, we&#39;ll add to this application to create our API. Don&#39;t worry if you don&#39;t understand each individual line of code yet—explanations will be forthcoming once you have this initial version of the application working.</p>
<div class="alert alert-warning">
<p><strong>Why Flask?</strong></p>

<p>Python has a number of web frameworks that can be used to create web apps and APIs. The most well-known is Django, a framework that has a set project structure and which includes many built-in tools. This can save time and effort for experienced programmers, but can be overwhelming. Flask applications tend to be written on a blank canvas, so to speak, and so are more suited to a contained application such as our prototype API.</p>
</div>

<p>First, create a new folder on your computer that will serve as a project folder. This can be in your <code>Desktop</code> folder, but I recommend creating a dedicated <code>projects</code> folder for this and similar projects. This tutorial will assume that the files related to this lesson will be stored in a folder called <code>api</code> inside a folder named <code>projects</code> in your home directory. If you need help with navigation on the command line, see the <a href="/lessons/intro-to-bash">Programming Historian Introduction to the Bash Command Line</a> for the macOS and Linux command line or the <a href="/lessons/intro-to-powershell">Introduction to the Windows Command Line with PowerShell</a> for Windows.</p>
<p>In macOS, you can directly create a an <code>api</code> folder inside a <code>projects</code> folder in your home directory with this terminal  command:</p>
<pre><code>mkdir -p ~/projects/api
</code></pre>
<p>On Windows, you can create the <code>api</code> folder with these commands in your <code>cmd</code> command line environment:</p>
<pre><code>md projects
cd projects
md api
</code></pre>
<p>You can also create the <code>projects</code> and <code>api</code> folders using your operating system&#39;s graphical user interface.</p>
<p>Next, open a text editor (such as Notepad++ or BBEdit) and enter the following code:</p>
<pre><code class="language-python">import flask

app = flask.Flask(__name__)
app.config[&quot;DEBUG&quot;] = True


@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])
def home():
    return &quot;&lt;h1&gt;Distant Reading Archive&lt;/h1&gt;&lt;p&gt;This site is a prototype API for distant reading of science fiction novels.&lt;/p&gt;&quot;

app.run()
</code></pre>
<p>Save this code as <code>api.py</code> in the <code>api</code> folder you created for this tutorial.</p>
<h2 id="running-the-application">Running the Application</h2>
<p>In the command line, navigate to your <code>api</code> folder:</p>
<pre><code>cd projects/api
</code></pre>
<p>You can check if you&#39;re in the correct folder by running the <code>pwd</code> command. Once you&#39;re in your project directory, run the Flask application with the command:</p>
<pre><code>python api.py
</code></pre>
<p>You should see output similar to this:</p>
<pre><code> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
</code></pre>
<p>You may also see some lines related to debugging. This message means that Flask is running your application locally (on your computer) at that address. Follow the link above, <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>, using your web browser to see the running application:</p>
<p>{% include figure.html filename=&quot;welcome.png&quot; caption=&quot;The home page when rendered in a browser.&quot; %}</p>
<p>Congratulations, you&#39;ve created a working web application!</p>
<h2 id="what-flask-does">What Flask Does</h2>
<p>Now that we have a homepage for our archive, let&#39;s talk about how Flask works and what the above code is doing.</p>
<p>Flask maps HTTP requests to Python functions. In this case, we&#39;ve mapped one URL path (&#39;<code>/</code>&#39;) to one function, <code>home</code>. When we connect to the Flask server at <a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>, Flask checks if there is a match between the path provided and a defined function. Since <code>/</code>, or no additional provided path, has been mapped to the <code>home</code> function, Flask runs the code in the function and displays the returned result in the browser. In this case, the returned result is HTML markup for a home page welcoming visitors to the site hosting our API.</p>
<p>The process of mapping URLs to functions is called <strong>routing</strong>. The</p>
<pre><code>@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])
</code></pre>
<p>syntax is the part of the program that lets Flask know that this function, <code>home</code>, should be mapped to the path <code>/</code>. The <code>methods</code> list (<code>methods=[&#39;GET&#39;]</code>) is a keyword argument that lets Flask know what kind of HTTP requests are allowed. We&#39;ll only be using <code>GET</code> requests in this tutorial, but many web applications need to use both <code>GET</code> requests (to send data from the application to the user) and <code>POST</code> requests (to receive data from a user).</p>
<p>Below are brief explanations of the other components of the application:</p>
<p><code>import flask</code> — Imports the Flask library, making the code available to the rest of the application.</p>
<p><code>app = flask.Flask(__name__)</code> — Creates the Flask application object, which contains data about the application and also methods (object functions) that tell the application to do certain actions. The last line, <code>app.run()</code>, is one such method.</p>
<p><code>app.config[&quot;DEBUG&quot;] = True</code> — Starts the debugger. With this line, if your code is malformed, you&#39;ll see an error when you visit your app. Otherwise you&#39;ll only see a generic message such as <code>Bad Gateway</code> in the browser when there&#39;s a problem with your code.</p>
<p><code>app.run()</code> — A method that runs the application server.</p>
<p>While it&#39;s useful to have a familiarity with what&#39;s going on in the script, don&#39;t worry if you don&#39;t understand precisely what every element is doing at this stage. If you understand the general outline of how this portion works, the details of how Flask renders pages are likely to become more understandable as we continue to develop our API.</p>
<h2 id="creating-the-api">Creating the API</h2>
<p>Now that we have a running Flask application and know a little about what Flask does, we&#39;re finally ready to implement a small API with data that we&#39;ll define right in our application.</p>
<p>We&#39;ll be adding our data as a list of Python dictionaries. Dictionaries in Python group pairs of keys and values, like this:</p>
<pre><code class="language-python">{
    &#39;key&#39;: &#39;value&#39;,
    &#39;key&#39;: &#39;value&#39;
}
</code></pre>
<p>The key identifies the type of information represented, such as <code>title</code> or <code>id</code>. The value is the actual data. For example, a short telephone book might take this format:</p>
<pre><code class="language-python">[
    {
        &#39;name&#39;: &#39;Alexander Graham Bell&#39;,
        &#39;number&#39;: &#39;1-333-444-5555&#39;
    },
    {
        &#39;name&#39;: &#39;Thomas A. Watson&#39;,
        &#39;number&#39;: &#39;1-444-555-6666&#39;
    }
]
</code></pre>
<p>The above phone book is a list of two dictionaries. Each dictionary is a phone book entry consisting of two keys, <code>name</code> and <code>number</code>, each paired with a value that provides the actual information.</p>
<p>Let&#39;s add some data (entries on three science fiction novels) as a list of dictionaries. Each dictionary will contain ID number, title, author, first sentence, and year of publication for each book. Finally, we&#39;ll add a new function: a route that will allow a visitor to access our data.</p>
<p>Replace our previous code in <code>api.py</code> with the code below:</p>
<pre><code class="language-python">import flask
from flask import request, jsonify

app = flask.Flask(__name__)
app.config[&quot;DEBUG&quot;] = True

# Create some test data for our catalog in the form of a list of dictionaries.
books = [
    {&#39;id&#39;: 0,
     &#39;title&#39;: &#39;A Fire Upon the Deep&#39;,
     &#39;author&#39;: &#39;Vernor Vinge&#39;,
     &#39;first_sentence&#39;: &#39;The coldsleep itself was dreamless.&#39;,
     &#39;year_published&#39;: &#39;1992&#39;},
    {&#39;id&#39;: 1,
     &#39;title&#39;: &#39;The Ones Who Walk Away From Omelas&#39;,
     &#39;author&#39;: &#39;Ursula K. Le Guin&#39;,
     &#39;first_sentence&#39;: &#39;With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.&#39;,
     &#39;published&#39;: &#39;1973&#39;},
    {&#39;id&#39;: 2,
     &#39;title&#39;: &#39;Dhalgren&#39;,
     &#39;author&#39;: &#39;Samuel R. Delany&#39;,
     &#39;first_sentence&#39;: &#39;to wound the autumnal city.&#39;,
     &#39;published&#39;: &#39;1975&#39;}
]


@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])
def home():
    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;/h1&gt;
&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;/p&gt;&#39;&#39;&#39;


# A route to return all of the available entries in our catalog.
@app.route(&#39;/api/v1/resources/books/all&#39;, methods=[&#39;GET&#39;])
def api_all():
    return jsonify(books)

app.run()
</code></pre>
<p>Run the code (navigate to your <code>api</code> folder in the command line and enter <code>python api.py</code>). Once the server is running, visit our route URL to view the data in the catalog:</p>
<p><a href="http://127.0.0.1:5000/api/v1/resources/books/all">http://127.0.0.1:5000/api/v1/resources/books/all</a></p>
<p>You should see JSON output for the three entries in our test catalog. Flask provides us with a <code>jsonify</code> function that allows us to convert lists and dictionaries to JSON format. In the route we created, our book entries are converted from a list of Python dictionaries to JSON before being returned to a user.</p>
<p>At this point, you&#39;ve created a working, if limited, API. In the next section, we&#39;ll allow users to find books via more specific data, such as an entry&#39;s ID.</p>
<h2 id="finding-specific-resources">Finding Specific Resources</h2>
<p>Right now, users can only view our entire database—they can&#39;t filter or find specific resources. While this isn&#39;t a problem with our test catalog, this will quickly become less useful as we add data. In this section, we&#39;ll add a function that allows users to filter their returned results using a more specific request.</p>
<p>Below is the code for our new application with filtering capability. As before, we&#39;ll examine the code more carefully once you have it running.</p>
<pre><code class="language-python">import flask
from flask import request, jsonify

app = flask.Flask(__name__)
app.config[&quot;DEBUG&quot;] = True

# Create some test data for our catalog in the form of a list of dictionaries.
books = [
    {&#39;id&#39;: 0,
     &#39;title&#39;: &#39;A Fire Upon the Deep&#39;,
     &#39;author&#39;: &#39;Vernor Vinge&#39;,
     &#39;first_sentence&#39;: &#39;The coldsleep itself was dreamless.&#39;,
     &#39;year_published&#39;: &#39;1992&#39;},
    {&#39;id&#39;: 1,
     &#39;title&#39;: &#39;The Ones Who Walk Away From Omelas&#39;,
     &#39;author&#39;: &#39;Ursula K. Le Guin&#39;,
     &#39;first_sentence&#39;: &#39;With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.&#39;,
     &#39;published&#39;: &#39;1973&#39;},
    {&#39;id&#39;: 2,
     &#39;title&#39;: &#39;Dhalgren&#39;,
     &#39;author&#39;: &#39;Samuel R. Delany&#39;,
     &#39;first_sentence&#39;: &#39;to wound the autumnal city.&#39;,
     &#39;published&#39;: &#39;1975&#39;}
]


@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])
def home():
    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;/h1&gt;
&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;/p&gt;&#39;&#39;&#39;


@app.route(&#39;/api/v1/resources/books/all&#39;, methods=[&#39;GET&#39;])
def api_all():
    return jsonify(books)


@app.route(&#39;/api/v1/resources/books&#39;, methods=[&#39;GET&#39;])
def api_id():
    # Check if an ID was provided as part of the URL.
    # If ID is provided, assign it to a variable.
    # If no ID is provided, display an error in the browser.
    if &#39;id&#39; in request.args:
        id = int(request.args[&#39;id&#39;])
    else:
        return &quot;Error: No id field provided. Please specify an id.&quot;

    # Create an empty list for our results
    results = []

    # Loop through the data and match results that fit the requested ID.
    # IDs are unique, but other fields might return many results
    for book in books:
        if book[&#39;id&#39;] == id:
            results.append(book)

    # Use the jsonify function from Flask to convert our list of
    # Python dictionaries to the JSON format.
    return jsonify(results)

app.run()
</code></pre>
<p>Once you&#39;ve updated your API with the <code>api_id</code> function, run your code as before (<code>python api.py</code> from your <code>api</code> directory) and visit the below URLs to test the new filtering capability:</p>
<p><a href="http://127.0.0.1:5000/api/v1/resources/books?id=0">127.0.0.1:5000/api/v1/resources/books?id=0</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?id=1">127.0.0.1:5000/api/v1/resources/books?id=1</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?id=2">127.0.0.1:5000/api/v1/resources/books?id=2</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?id=3">127.0.0.1:5000/api/v1/resources/books?id=3</a></p>
<p>Each of these should return a different entry, except for the last, which should return an empty list: <code>[]</code>, since there is no book for which the id value is 3. (Counting in programming typically starts from 0, so id=3 would be a request for a nonexistent fourth item.) In the next section, we&#39;ll explore our updated API in more detail.</p>
<h2 id="understanding-our-updated-api">Understanding Our Updated API</h2>
<p>In this code, we first create a new function, called <code>api_id</code>, with the <code>@app.route</code> syntax that maps the function to the path <code>/api/v1/resources/books</code>. That means that this function will run when we access <a href="http://127.0.0.1:5000/api/v1/resources/books">http://127.0.0.1:5000/api/v1/resources/books</a>. (Note that accessing this link without providing an ID will give the error message we provided in the code: <code>Error: No id field provided. Please specify an id.</code>)</p>
<p>Inside our function, we do two things:</p>
<p>First, examine the provided URL for an id and select the books that match that id. The id must be provided like this: <code>?id=0</code>. Data passed through URLs like this (after the <code>?</code>) are called <strong>query parameters</strong>—we&#39;ve seen them before when we worked with the Chronicling America API. They&#39;re a feature of HTTP used for filtering for specific kinds of data.</p>
<p>This part of the code determines if there is a query parameter, like <code>?id=0</code>, and then assigns the provided ID to a variable.</p>
<pre><code>    if &#39;id&#39; in request.args:
        id = int(request.args[&#39;id&#39;])
    else:
        return &quot;Error: No id field provided. Please specify an id.&quot;
</code></pre>
<p>Then this section moves through our test catalog of books, matches those books that have the provided ID, and appends them to the list that will be returned to the user:</p>
<pre><code>    for book in books:
        if book[&#39;id&#39;] == id:
            results.append(book)
</code></pre>
<p>Finally, the <code>return jsonify(results)</code> line takes the list of results and renders them in the browser as JSON.</p>
<p>If you&#39;ve gotten this far, you&#39;ve created an actual API. Celebrate! At the end of this lesson, you&#39;ll be exposed to a somewhat more complex API that uses a database, but most of the principles and patterns we&#39;ve used so far will still apply. In the next section, we&#39;ll discuss some guidelines for creating a well-designed API that others will actually want to use. In the last section of the tutorial, we&#39;ll apply these principles to a version of our API that pulls in results from a database.</p>
<h1 id="api-design-principles">API Design Principles</h1>
<p>Thus far, we&#39;ve created a working API with test data that we&#39;ve provided right in our application. Our next version of our API will pull in data from a database before providing it to a user. It will also take additional query parameters, allowing users to filter by fields other than ID.</p>
<p>Before building more functionality into our application, let&#39;s reflect on some of the API design decisions that we&#39;ve made so far. Two aspects of a good API are usability and maintainability, and as we build more functionality into our API, we&#39;ll be keeping many of the following considerations in mind.</p>
<h2 id="designing-requests">Designing Requests</h2>
<p>The prevailing design philosophy of modern APIs is called REST. For our purposes, the most important thing about REST is that it&#39;s based on the four methods defined by the HTTP protocol: POST, GET, PUT, and DELETE. These correspond to the four traditional actions performed on data in a database: CREATE, READ, UPDATE, and DELETE. In this tutorial, we&#39;ll only be concerned with GET requests, which correspond to reading from a database.</p>
<p>Because HTTP requests are so integral to using a REST API, many design principles revolve around how requests should be formatted. We&#39;ve already created one HTTP request, which returns all books provided in our sample data. To understand the considerations that go into formatting this request, let&#39;s first consider a weak or poorly-designed example of an API endpoint:</p>
<pre><code>http://api.example.com/getbook/10
</code></pre>
<p>The formatting of this request has a number of issues. The first is semantic—in a REST API, our verbs are typically <code>GET</code>, <code>POST</code>, <code>PUT</code>, or <code>DELETE</code>, and are determined by the request method rather than in the request URL. That means that the word &quot;get&quot; should not appear in our request, since &quot;get&quot; is implied by the fact that we&#39;re using a HTTP GET method. In addition, resource collections such as <code>books</code> or <code>users</code> should be denoted with plural nouns. This makes it clear when an API is referring to a collection (<code>books</code>) or an entry (<code>book</code>). Incorporating these principles, our API would look like this:</p>
<pre><code>http://api.example.com/books/10
</code></pre>
<p>The above request uses part of the path (<code>/10</code>) to provide the ID. While this is not an uncommon approach, it&#39;s somewhat inflexible—with URLs constructed in this manner, you can generally only filter by one field at a time. Query parameters allow for filtering by multiple database fields and make more sense when providing &quot;optional&quot; data, such as an output format:</p>
<pre><code>http://api.example.com/books?author=Ursula+K.+Le Guin&amp;published=1969&amp;output=xml
</code></pre>
<p>When designing how requests to your API should be structured, it also makes sense to plan for future additions. Even if the current version of your API serves information on only one type of resource—<code>books</code>, for example—it makes sense to plan as if you might add other resources or non-resource functionality to your API in the future:</p>
<pre><code>http://api.example.com/resources/books?id=10
</code></pre>
<p>Adding an extra segment on your path  such as &quot;resources&quot; or &quot;entries&quot; gives you the option to allow users to search across all resources available, making it easier for you to later support requests such as these:</p>
<pre><code>https://api.example.com/v1/resources/images?id=10
https://api.example.com/v1/resources/all
</code></pre>
<p>Another way to plan for your API&#39;s future is to add a version number to the path. This means that, should you have to redesign your API, you can continue to support the old version of the API under the old version number while releasing, for example, a second version (<code>v2</code>) with improved or different functionality. This way, applications and scripts built using the old version of your API won&#39;t cease to function after your upgrade.</p>
<p>After incorporating these design improvements, a request to our API might look like this:</p>
<pre><code>https://api.example.com/v1/resources/books?id=10
</code></pre>
<h2 id="documentation-and-examples">Documentation and Examples</h2>
<p>Without documentation, even the best-designed API will be unusable. Your API should have documentation describing the resources or functionality available through your API that also provides concrete working examples of request URLs or code for your API. You should have a section for each resource that describes which fields, such as <code>id</code> or <code>title</code>, it accepts. Each section should have an example in the form of a sample HTTP request or block of code.</p>
<p>A fairly common practice in documenting APIs is to provide annotations in your code that are then automatically collated into documentation using a tool such as <a href="http://www.doxygen.org/">Doxygen</a> or <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a>. These tools create documentation from <strong>docstrings</strong>—comments you make on your function definitions. While this kind of documentation is a good idea, you shouldn&#39;t consider your job done if you&#39;ve only documented your API to this level. Instead, try to imagine yourself as a potential user of your API and provide working examples. In an ideal world, you would have three kinds of documentation for your API: a reference that details each route and its behavior, a guide that explains the reference in prose, and at least one or two tutorials that explain every step in detail.</p>
<p>For inspiration on how to approach API documentation, see the <a href="http://api.repo.nypl.org/">New York Public Library Digital Collections API</a>, which sets a standard of documentation achievable for many academic projects. For an extensively documented (though sometimes overwhelming) API, see the <a href="https://www.mediawiki.org/wiki/API:Main_page">MediaWiki Action API</a>, which provides documentation to users who pass partial queries to the API. (In our example above, we returned an error on a partial query.) For other professionally maintained API documentation examples, consider the <a href="https://datahelpdesk.worldbank.org/knowledgebase/articles/889392-api-documentation">World Bank API</a>, the various <a href="https://developer.nytimes.com/">New York Times APIs</a>, or the <a href="https://pro.europeana.eu/resources/apis">Europeana Pro API</a>.</p>
<h1 id="connecting-our-api-to-a-database">Connecting Our API to a Database</h1>
<p>This last example of our Distant Reading Archive API pulls in data from a database, implements error handling, and can filter books by publication date. The database used is SQLite, a lightweight database engine that is supported in Python by default. SQLite files typically end with the <code>.db</code> file extension.</p>
<p>Before we modify our code, first <a href="/assets/creating-apis-with-python-and-flask/books.db">download the example database from this location</a> and copy the file to your <code>api</code> folder using your graphical user interface. The final version of our API will query this database when returning results to users.</p>
<p>Copy the below code into your text editor. As before, we&#39;ll examine the code more closely once you have it running.</p>
<pre><code class="language-python">import flask
from flask import request, jsonify
import sqlite3

app = flask.Flask(__name__)
app.config[&quot;DEBUG&quot;] = True

def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])
def home():
    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;/h1&gt;
&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;/p&gt;&#39;&#39;&#39;


@app.route(&#39;/api/v1/resources/books/all&#39;, methods=[&#39;GET&#39;])
def api_all():
    conn = sqlite3.connect(&#39;books.db&#39;)
    conn.row_factory = dict_factory
    cur = conn.cursor()
    all_books = cur.execute(&#39;SELECT * FROM books;&#39;).fetchall()

    return jsonify(all_books)



@app.errorhandler(404)
def page_not_found(e):
    return &quot;&lt;h1&gt;404&lt;/h1&gt;&lt;p&gt;The resource could not be found.&lt;/p&gt;&quot;, 404


@app.route(&#39;/api/v1/resources/books&#39;, methods=[&#39;GET&#39;])
def api_filter():
    query_parameters = request.args

    id = query_parameters.get(&#39;id&#39;)
    published = query_parameters.get(&#39;published&#39;)
    author = query_parameters.get(&#39;author&#39;)

    query = &quot;SELECT * FROM books WHERE&quot;
    to_filter = []

    if id:
        query += &#39; id=? AND&#39;
        to_filter.append(id)
    if published:
        query += &#39; published=? AND&#39;
        to_filter.append(published)
    if author:
        query += &#39; author=? AND&#39;
        to_filter.append(author)
    if not (id or published or author):
        return page_not_found(404)

    query = query[:-4] + &#39;;&#39;

    conn = sqlite3.connect(&#39;books.db&#39;)
    conn.row_factory = dict_factory
    cur = conn.cursor()

    results = cur.execute(query, to_filter).fetchall()

    return jsonify(results)

app.run()
</code></pre>
<p>Save the code as <code>api_final.py</code> in your <code>api</code> folder and run it by navigating to your project folder in the terminal and entering the command:</p>
<pre><code>python api_final.py
</code></pre>
<p>Note that if a previous version of the code is still running, you will first need to end that process by pressing <code>Control-C</code> before executing the new code. Once this example is running, try out the filtering functionality with these HTTP requests:</p>
<p><a href="http://127.0.0.1:5000/api/v1/resources/books/all">http://127.0.0.1:5000/api/v1/resources/books/all</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?author=Connie+Willis">http://127.0.0.1:5000/api/v1/resources/books?author=Connie+Willis</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?author=Connie+Willis&amp;published=1993">http://127.0.0.1:5000/api/v1/resources/books?author=Connie+Willis&amp;published=1999</a>
<a href="http://127.0.0.1:5000/api/v1/resources/books?published=2010">http://127.0.0.1:5000/api/v1/resources/books?published=2010</a></p>
<p>The database downloaded for this lesson has 67 entries, one for each of the winners of the Hugo Award for best science fiction novel between 1953 and 2014 (avoiding the voting controversy of 2015). The data set includes the novel&#39;s title, author, year of publication, and first sentence. Our API allows users to filter by three fields: <code>id</code>, <code>published</code> (year of publication), and <code>author</code>.</p>
<p>The first request returns all entries in the database, similar to the <code>/all</code> request we implemented for the last version of our API. The second request returns all books by the author Connie Willis (<code>?author=Connie+Willis</code>). Note that, within a query parameter, spaces between words are denoted with a <code>+</code> sign, hence <code>Connie+Willis</code>. The third request filters by two fields—author and year of publication. Instead of the three books returned by requesting <code>?author=Connie+Willis</code>, this request returns only the entry to <em>The Doomsday Book</em>, published in 1993. The last request returns all Hugo winners from the year 2010 (note that, in some years, more than one Hugo is awarded).</p>
<p>As we can see this version of our API serves a larger number of results, results that are stored in an SQLite database (<code>books.db</code>). When our user requests an entry or set of entries, our API pulls that information from the database by building and executing an SQL query. This iteration of our API also allows for filtering by more than one field. We&#39;ll discuss potential uses for this functionality after examining our code more closely.</p>
<h2 id="understanding-our-database-powered-api">Understanding Our Database-Powered API</h2>
<p>Relational databases allow for the storage and retrieval of data, which is stored in tables. Tables are similar to spread sheets in that they have columns and rows—columns indicate what the data representes, such as &quot;title&quot; or &quot;date.&quot; Rows represent individual entries, which could be books, users, transactions, or any other kind of entity.</p>
<p>The database we&#39;re working with has five columns <code>id</code>, <code>published</code>, <code>author</code>, <code>title</code>, and <code>first_sentence</code>. Each row represents one book that won the Hugo award in the year under the <code>published</code> heading, and the text of which begins with the sentence in the <code>first_sentence</code> column.</p>
<p>Rather than use test data defined in the application, our <code>api_all</code> function pulls in data from our Hugo database:</p>
<pre><code class="language-python">def api_all():
    conn = sqlite3.connect(&#39;books.db&#39;)
    conn.row_factory = dict_factory
    cur = conn.cursor()
    all_books = cur.execute(&#39;SELECT * FROM books;&#39;).fetchall()

    return jsonify(all_books)
</code></pre>
<p>First, we connect to the database using our <code>sqlite3</code> library. An object representing the connection to the database is bound to the <code>conn</code> variable. The <code>conn.row_factory = dict_factory</code> line lets the connection object know to use the <code>dict_factory</code> function we&#39;ve defined, which returns items from the database as dictionaries rather than lists—these work better when we output them to JSON. We then create a cursor object (<code>cur = conn.cursor()</code>), which is the object that actually moves through the database to pull our data. Finally, we execute an SQL query with the <code>cur.execute</code> method to pull out all available data (<code>*</code>) from the <code>books</code> table of our database. At the end of our function, this data is returned as JSON: <code>jsonify(all_books)</code>. Note that our other function that returns data, <code>api_filter</code>, will use a similar approach to pull data from the database.</p>
<p>The purpose of our <code>page_not_found</code> function is to create an error page seen by the user if the user encounters an error or inputs a route that hasn&#39;t been defined:</p>
<pre><code class="language-python">@app.errorhandler(404)
def page_not_found(e):
    return &quot;&lt;h1&gt;404&lt;/h1&gt;&lt;p&gt;The resource could not be found.&lt;/p&gt;&quot;, 404
</code></pre>
<p>In HTML responses, the code <code>200</code> means &quot;OK&quot;(the expected data transferred), while the code <code>404</code> means &quot;Not Found&quot; (there was no resource available at the URL given). This function allows us to return 404 pages when something goes wrong in the application.</p>
<p>Our <code>api_filter</code> function is an improvement on our previous <code>api_id</code> function that returns a book based on its ID. This new function allows for filtering by three different fields: <code>id</code>, <code>published</code>, and <code>author</code>. The function first grabs all the query parameters provided in the URL (remember, query parameters are the part of the URL that follows the <code>?</code>, like <code>?id=10</code>).</p>
<pre><code>query_parameters = request.args
</code></pre>
<p>It then pulls the supported parameters <code>id</code>, <code>published</code>, and <code>author</code> and binds them to appropriate variables:</p>
<pre><code>id = query_parameters.get(&#39;id&#39;)
published = query_parameters.get(&#39;published&#39;)
author = query_parameters.get(&#39;author&#39;)
</code></pre>
<p>The next segment begins to build an SQL query that will be used to find the requested information in the database. SQL queries used to find data in a database take this form:</p>
<pre><code>`SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE &lt;column=match&gt; AND &lt;column=match&gt;;
</code></pre>
<p>To get the correct data, we need to build both an SQL query that looks like the above and a list with the filters that will be matched. Combined, the query and the the filters provided by the user will allow us to pull the correct books from our database.</p>
<p>We begin to define both the query and the filter list:</p>
<pre><code>query = &quot;SELECT * FROM books WHERE&quot;
to_filter = []
</code></pre>
<p>Then, if <code>id</code>, <code>published</code>, or <code>author</code> were provided as query parameters, we add them to both the query and the filter list:</p>
<pre><code class="language-python">    if id:
        query += &#39; id=? AND&#39;
        to_filter.append(id)
    if published:
        query += &#39; published=? AND&#39;
        to_filter.append(published)
    if author:
        query += &#39; author=? AND&#39;
        to_filter.append(author)
</code></pre>
<p>If the user has provided none of these query parameters, we have nothing to show, so we send them to the &quot;404 Not Found&quot; page:</p>
<pre><code class="language-python">    if not (id or published or author):
        return page_not_found(404)
</code></pre>
<p>To perfect our query, we remove the trailing <code> AND</code> and cap the query with the <code>;</code> required at the end of all SQL statements:</p>
<pre><code class="language-python">    query = query[:-4] + &#39;;&#39;
</code></pre>
<p>Finally, we connect to our database as in our <code>api_all</code> function, then execute the query we&#39;ve built using our filter list:</p>
<pre><code>conn = sqlite3.connect(&#39;books.db&#39;)
conn.row_factory = dict_factory
cur = conn.cursor()

results = cur.execute(query, to_filter).fetchall()
</code></pre>
<p>Finally, we return the results of our executed SQL query as JSON to the user:</p>
<pre><code>return jsonify(results)
</code></pre>
<p>Whew! When all is said and done, this section of code reads query parameters provided by the user, builds an SQL query based on those parameters, executes that query to find matching books in the database, and returns those matches as JSON to the user. This section of code makes our API&#39;s filtering capability considerably more sophisticated—users can now find books by, for example, Ursula K. Le Guin that were published in 1975 or all books in the database published in 2010.</p>
<h2 id="our-api-in-practice">Our API in Practice</h2>
<p>Now that we have implemented our Distant Reading API, let&#39;s consider how it might be of use in digital projects and in research.</p>
<p>One of the advantages of providing data through an API, as opposed to providing some kind of downloadable database or file for users, is that, as new data or additional resources are added, they become immediately available to projects built using the API. Imagine that we make our API publicly available, and a user creates a visualization that plots the length of a novel&#39;s first sentence in characters against its year of publication:</p>
<p>{% include figure.html filename=&quot;hugo.png&quot; caption=&quot;Scatterplot of first sentence length against date of publication.&quot; %}</p>
<p>As new Hugo winners were added to the database, the script that generated this visualization would immediately be able to use the new information. If the visualization were created in D3 or another web-based utility, this plot would actually reflect additional data added to the book archive as soon as the archive was updated—that is, in real time. As additional data accrued, we might, for example, learn if John Scalzi&#39;s unusually lengthy opening to his 2013 <em>Red Shirts</em> was an aberration or the continuation of a longer trend toward wordiness in science fiction. Conversely, if your API were to change its URL structure or cease to function, applications based on it will no longer work. Remember that, when creating an API, you are assuming some responsibility for the applications that others may build with it.</p>
<p>A strong API can be considered the backbone of a potentially limitless number of projects or avenues of research. Though the above example takes the form of a visualization of the limited amount of data we&#39;ve provided in our Distant Reading Archive, a project based on this API might just as easily take the form of a Twitterbot that shares first sentences (learn how to make one with <a href="/lessons/intro-to-twitterbots">this</a> Programming Historian lesson) or a library webpage that displays book openings and year of publication alongside other book metadata. In many cases, it makes sense to first create an API interface to your core data or functionality before extrapolating on it to create a visualization, application, or website. Not only does it make your work accessible to researchers working on other projects, but it often leads to a more comprehensible and maintainable project.</p>
<h1 id="resources">Resources</h1>
<p>The below resources provide information on useful APIs for researchers in the humanities and social sciences as well as further reading on API concepts.</p>
<h2 id="apis-for-humanities-researchers">APIs for Humanities Researchers</h2>
<p><a href="http://chroniclingamerica.loc.gov/">Chronicling America (Library Of Congress)</a> - A digitized collection of American newspaper articles from the 18th to the 20th century.</p>
<p><a href="https://core.ac.uk/">Connecting Repositories (CORE)</a> - A collection of open access articles from various sources hosted by the Open University.</p>
<p><a href="https://diggingintodata.org/repositories/english-broadside-ballad-archive-ebba">English Broadside Ballad Archive (EBBA)</a></p>
<p><a href="http://hds.essex.ac.uk/">History Data Service (HDS)</a> - A collection of data from a wide variety of historical sources.</p>
<p><a href="https://pro.europeana.eu/">Europeana</a></p>
<p><a href="https://diggingintodata.org/repositories">Digging into Data API List</a></p>
<h2 id="api-resources">API Resources</h2>
<p><a href="https://doepud.co.uk/blog/anatomy-of-a-url">Anatomy of a URL</a> - Explains the different sections of a URL (protocol, domain, path, and so on) in greater detail.</p>
<p><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Original Paper on REST</a>  - PhD thesis by Roy Thomas Fielding that introduced the concepts behind the REST philosophy of API design.</p>
<p><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">The Flask Mega Tutorial</a> - The most well-known tutorial for learning the Flask web framework.</p>
<!-- HTML_TAG_END -->

<script type="application/json" data-type="svelte-data" data-url="creating-apis-with-python-and-flask/raw.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"metadata\":{\"title\":\"Creating Web APIs with Python and Flask\\n\",\"collection\":\"lessons\",\"layout\":\"lesson\",\"slug\":\"creating-apis-with-python-and-flask\",\"date\":\"2018-04-02T00:00:00.000Z\",\"authors\":[\"Patrick Smyth\"],\"reviewers\":[\"Ryan Deschamps\",\"Megan Kudzia\"],\"editors\":[\"Brandon Walsh\"],\"difficulty\":2,\"activity\":\"presenting\",\"topics\":[\"api\",\"data-management\"],\"review-ticket\":\"https:\u002F\u002Fgithub.com\u002Fprogramminghistorian\u002Fph-submissions\u002Fissues\u002F106\",\"abstract\":\"Learn how to set up a basic Application Programming Interface (API) to make your data more accessible to users. This lesson also discusses principles of API design and the benefits of APIs for digital projects.\\n\",\"redirect_from\":\"\u002Flessons\u002Fcreating-apis-with-python-and-flask\",\"avatar_alt\":\"Diagram with a series of arcs describing a quarter circle\",\"doi\":\"10.46430\u002Fphen0072\"},\"html_body\":\"\u003Cp\u003E{% include toc.html %}\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"lesson-goals\\\"\u003ELesson Goals\u003C\u002Fh1\u003E\\n\u003Cp\u003EWeb APIs are tools for making information and application functionality accessible over the internet. In this lesson, you will:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003ELearn what an API is and when you should use one.\u003C\u002Fli\u003E\\n\u003Cli\u003ELearn how to build a web API that returns data to its users.\u003C\u002Fli\u003E\\n\u003Cli\u003ELearn some principles of good API design, applying them to an API that draws book metadata from a database.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"setting-up\\\"\u003ESetting Up\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"prerequisites\\\"\u003EPrerequisites\u003C\u002Fh2\u003E\\n\u003Cp\u003EYou can use the Windows, macOS, or Linux operating systems to complete this tutorial, and those few instructions that are not the same across platforms will be explicitly noted. Python 3, the Flask web framework, and a web browser are required for this tutorial, and installation instructions for all platforms are outlined below.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe only knowledge explicitly assumed for this lesson is the ability to use a text editor, such as BBEdit on macOS or Notepad++ on Windows. However, knowledge of the command line, Python, and web concepts such as HTTP may make this tutorial easier to follow. If you&#39;re new to Python, consider working through the Programming Historian series on \u003Ca href=\\\"\u002Flessons\u002Fintroduction-and-installation\\\"\u003Edealing with online sources\u003C\u002Fa\u003E to familiarize yourself with fundamental concepts in Python programming.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"installing-python-and-flask\\\"\u003EInstalling Python and Flask\u003C\u002Fh2\u003E\\n\u003Cp\u003EFor this tutorial, you will need Python 3 and the Flask web framework. You&#39;ll also require a web browser (such as Firefox) and a text editor (such as Notepad++ or BBEdit).\u003C\u002Fp\u003E\\n\u003Cp\u003ETo download Python, follow \u003Ca href=\\\"https:\u002F\u002Fwww.python.org\u002Fdownloads\u002F\\\"\u003Ethis link\u003C\u002Fa\u003E, select the button that says \u003Ccode\u003EDownload Python 3.x.x\u003C\u002Fcode\u003E, and then run the installer as you normally would to install applications on your operating system. The default settings should be fine.\u003C\u002Fp\u003E\\n\u003Cp\u003ETo confirm that Python installed successfully, first open the command line. In macOS, click the spotlight icon on the top right corner of your desktop (the magnifying glass) and type terminal. The terminal should be the first application that appears. On Windows, click the Start menu icon and type \u003Ccode\u003Ecmd\u003C\u002Fcode\u003E in the search box, then press \u003Ccode\u003EEnter\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EOnce your command line is open, enter these commands:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython --version\\npip --version\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIf the output for these commands includes a version number, Python is installed and available from the command line and you can proceed to the next step.\u003C\u002Fp\u003E\\n\u003Cp\u003ENext, you&#39;ll need to install Flask. At the command line, type\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epip install flask\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThis will install Flask using the pip package manager for Python. You should see some output ending in a notification that Flask has been installed successfully.\u003C\u002Fp\u003E\\n\u003Cp\u003EAs an alternative to the above installation instructions, you can install the Python 3 version of Anaconda, which can be downloaded \u003Ca href=\\\"https:\u002F\u002Fwww.continuum.io\\\"\u003Ehere\u003C\u002Fa\u003E. Anaconda comes with Flask, so if you go this route you will not need to install Flask using the pip package manager.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you&#39;re running into trouble installing Python, you may find \u003Ca href=\\\"\u002Flessons\u002Fintroduction-and-installation\\\"\u003Ethis Programming Historian article on installing Python\u003C\u002Fa\u003E helpful. Note that the instructions in that tutorial are for installing Python 2—make sure you choose Python 3 when downloading installers from the Python website, since this tutorial uses Python 3.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you don&#39;t have a preferred text editor, I recommend \u003Ca href=\\\"https:\u002F\u002Fwww.barebones.com\u002Fproducts\u002Fbbedit\u002Fdownload.html\\\"\u003EBBEdit\u003C\u002Fa\u003E for macOS or \u003Ca href=\\\"https:\u002F\u002Fnotepad-plus-plus.org\u002F\\\"\u003ENotepad++\u003C\u002Fa\u003E for Windows.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"introducing-apis\\\"\u003EIntroducing APIs\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"what-is-an-api\\\"\u003EWhat is an API?\u003C\u002Fh2\u003E\\n\u003Cp\u003EIf you&#39;ve heard the term API before, chances are it&#39;s been used not to refer to APIs in general, but instead to a specific kind of API, the web API. A web API allows for information or functionality to be manipulated by other programs via the internet. For example, with Twitter&#39;s web API, you can write a program in a language like Python or Javascript that can perform tasks such as favoriting tweets or collecting tweet metadata.\u003C\u002Fp\u003E\\n\u003Cp\u003EIn programming more generally, the term API, short for Application Programming Interface, refers to a part of a computer program designed to be used or manipulated by another program, as opposed to an interface designed to be used or manipulated by a human. Computer programs frequently need to communicate amongst themselves or with the underlying operating system, and APIs are one way they do it. In this tutorial, however, we&#39;ll be using the term API to refer specifically to web APIs.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"when-to-create-an-api\\\"\u003EWhen to Create an API\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn general, consider an API if:\u003C\u002Fp\u003E\\n\u003Col\u003E\\n\u003Cli\u003EYour data set is large, making download via FTP unwieldy or resource-intensive.\u003C\u002Fli\u003E\\n\u003Cli\u003EYour users will need to access your data in real time, such as for display on another website or as part of an application.\u003C\u002Fli\u003E\\n\u003Cli\u003EYour data changes or is updated frequently.\u003C\u002Fli\u003E\\n\u003Cli\u003EYour users only need access to a part of the data at any one time.\u003C\u002Fli\u003E\\n\u003Cli\u003EYour users will need to perform actions other than retrieve data, such as contributing, updating, or deleting data.\u003C\u002Fli\u003E\\n\u003C\u002Fol\u003E\\n\u003Cp\u003EIf you have data you wish to share with the world, an API is one way you can get it into the hands of others. However, APIs are not always the best way of sharing data with users. If the size of the data you are providing is relatively small, you can instead provide a &quot;data dump&quot; in the form of a downloadable JSON, XML, CSV, or SQLite file. Depending on your resources, this approach can be viable up to a download size of a few gigabytes.\u003C\u002Fp\u003E\\n\u003Cp\u003ERemember that you can provide both a data dump and an API, and individual users may find one or the other to better match their use case. \u003Ca href=\\\"https:\u002F\u002Fopenlibrary.org\u002F\\\"\u003EOpen Library\u003C\u002Fa\u003E, for example, provides both \u003Ca href=\\\"https:\u002F\u002Fopenlibrary.org\u002Fdevelopers\u002Fdumps\\\"\u003Ea data dump\u003C\u002Fa\u003E and \u003Ca href=\\\"https:\u002F\u002Fopenlibrary.org\u002Fdevelopers\u002Fapi\\\"\u003Ean API\u003C\u002Fa\u003E, each of which serves different use cases for different users.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"api-terminology\\\"\u003EAPI Terminology\u003C\u002Fh2\u003E\\n\u003Cp\u003EWhen using or building APIs, you will encounter these terms frequently:\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cstrong\u003EHTTP (Hypertext Transfer Protocol)\u003C\u002Fstrong\u003E is the primary means of communicating data on the web. HTTP implements a number of &quot;methods,&quot; which tell which direction data is moving and what should happen to it. The two most common are GET, which pulls data from a server, and POST, which pushes new data to a server.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cstrong\u003EURL (Uniform Resource Locator)\u003C\u002Fstrong\u003E - An address for a resource on the web, such as \u003Ccode\u003Ehttps:\u002F\u002Fprogramminghistorian.org\u002Fabout\u003C\u002Fcode\u003E. A URL consists of a \u003Cstrong\u003Eprotocol\u003C\u002Fstrong\u003E (\u003Ccode\u003Ehttp:\u002F\u002F\u003C\u002Fcode\u003E), domain (\u003Ccode\u003Eprogramminghistorian.org\u003C\u002Fcode\u003E), and optional \u003Cstrong\u003Epath\u003C\u002Fstrong\u003E (\u003Ccode\u003E\u002Fabout\u003C\u002Fcode\u003E). A URL describes the location of a specific resource, such as a web page. When reading about APIs, you may see the terms \u003Ccode\u003EURL\u003C\u002Fcode\u003E, \u003Ccode\u003Erequest\u003C\u002Fcode\u003E, \u003Ccode\u003EURI\u003C\u002Fcode\u003E, or \u003Ccode\u003Eendpoint\u003C\u002Fcode\u003E used to describe adjacent ideas. This tutorial will prefer the terms URL and request to avoid complication. You can follow a URL or make a GET request in your browser, so you won&#39;t need any special software to make requests in this tutorial.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cstrong\u003EJSON (JavaScript Object Notation)\u003C\u002Fstrong\u003E is a text-based data storage format that is designed to be easy to read for both humans and machines. JSON is generally the most common format for returning data through an API, XML being the second most common.\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cstrong\u003EREST (REpresentational State Transfer)\u003C\u002Fstrong\u003E is a philosophy that describes some best practices for implementing APIs. APIs designed with some or all of these principles in mind are called REST APIs. While the API outlined in this lesson uses some REST principles, there is a great deal of disagreement around this term. For this reason, I do not describe the example APIs here as REST APIs, but instead as web or HTTP APIs.\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"using-apis\\\"\u003EUsing APIs\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"why-use-apis-as-a-researcher\\\"\u003EWhy Use APIs as a Researcher?\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe primary focus of this lesson is on creating an API, not exploring or using an API that has already been implemented. However, before we start building our own API, it may be useful to discuss how APIs are useful for researchers. In this section, we&#39;ll see how APIs can be useful for approaching historical, textual, or sociological questions using a &quot;macroscopic&quot; or &quot;distant reading&quot; approach that makes use of relatively large amounts of information. In doing so, we&#39;ll familiarize ourselves with the basic elements of a good API. Considering APIs from the perspective of a user will come in useful when we begin to design our own API later in the lesson.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"an-api-case-study-sensationalism-and-historical-fires\\\"\u003EAn API Case Study: Sensationalism and Historical Fires\u003C\u002Fh2\u003E\\n\u003Cp\u003EImagine that our research area is sensationalism and the press: has newspaper coverage of major events in the United States become more or less sensational over time? Narrowing the topic, we might ask whether press coverage of, for example, urban fires has increased or decreased with government reporting on fire-related relief spending.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhile we won&#39;t be able to explore this question thoroughly, we can begin to approach this research space by collecting historical data on newspaper coverage of fires using an API—in this case, the \u003Ca href=\\\"http:\u002F\u002Fchroniclingamerica.loc.gov\u002Fabout\u002Fapi\u002F\\\"\u003EChronicling America Historical Newspaper API\u003C\u002Fa\u003E. The Chronicling America API allows access to metadata and text for millions of scanned newspaper pages. In addition, unlike many other APIs, it also does not require an authentication process, allowing us to immediately explore the available data without signing up for an account.\u003C\u002Fp\u003E\\n\u003Cp\u003EOur initial goal in approaching this research question is to find all newspaper stories in the Chronicling America database that use the term &quot;fire.&quot; Typically, use of an API starts with its documentation. On the \u003Ca href=\\\"http:\u002F\u002Fchroniclingamerica.loc.gov\u002Fabout\u002Fapi\u002F\\\"\u003EChronicling America API page\u003C\u002Fa\u003E, we find two pieces of information critical for getting the data we want from the API: the API&#39;s \u003Cstrong\u003Ebase URL\u003C\u002Fstrong\u003E and the \u003Cstrong\u003Epath\u003C\u002Fstrong\u003E corresponding to the function we want to perform on the API—in this case, searching the database.\u003C\u002Fp\u003E\\n\u003Cp\u003EOur base URL is:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fchroniclingamerica.loc.gov\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAll requests we make to the API must begin with this portion of the URL. All APIs have a base URL like this one that is the same across all requests to the API.\u003C\u002Fp\u003E\\n\u003Cp\u003EOur path is:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E\u002Fsearch\u002Fpages\u002Fresults\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIf we combine the base URL and the path together into one URL, we&#39;ll have created a request to the Chronicling America API that returns all available data in the database:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fchroniclingamerica.loc.gov\u002Fsearch\u002Fpages\u002Fresults\u002F\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIf you \u003Ca href=\\\"http:\u002F\u002Fchroniclingamerica.loc.gov\u002Fsearch\u002Fpages\u002Fresults\u002F\\\"\u003Evisit the link above\u003C\u002Fa\u003E, you&#39;ll see all items available in Chronicling America (12,243,633 at the time of writing), , not just the entries related to our search term, &quot;fire.&quot; This request also returns a formatted HTML view, rather than the structured view we want to use to collect data.\u003C\u002Fp\u003E\\n\u003Cp\u003EAccording to the Chronicling America documentation, in order to get structured data specifically relating to fire, we need to pass one more kind of data in our request: \u003Cstrong\u003Equery parameters\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fchroniclingamerica.loc.gov\u002Fsearch\u002Fpages\u002Fresults\u002F?format=json&amp;proxtext=fire\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe query parameters follow the \u003Ccode\u003E?\u003C\u002Fcode\u003E in the request, and are seperated from one another by the \u003Ccode\u003E&amp;\u003C\u002Fcode\u003E symbol. The first query parameter, \u003Ccode\u003Eformat=json\u003C\u002Fcode\u003E, changes the returned data from HTML to JSON. The second, \u003Ccode\u003Eproxtext=fire\u003C\u002Fcode\u003E, narrows the returned entries to those that include our search term.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you \u003Ca href=\\\"http:\u002F\u002Fchroniclingamerica.loc.gov\u002Fsearch\u002Fpages\u002Fresults\u002F?format=json&amp;proxtext=fire\\\"\u003Efollow the above link\u003C\u002Fa\u003E in your browser, you&#39;ll see a structured list of the items in the database related to the search term &quot;fire.&quot; The format of the returned data is called JSON, and is a structured format that looks like this excerpt from the Chronicling America results:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-json\\\"\u003E&quot;city&quot;: [\\n        &quot;Washington&quot;\\n      ],\\n      &quot;date&quot;: &quot;19220730&quot;,\\n      &quot;title&quot;: &quot;The Washington Herald.&quot;,\\n      &quot;end_year&quot;: 1939,\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EBy making requests to the Chronicling America API, we&#39;ve accessed information on news stories that contain the search term &quot;fire,&quot; and returned data that includes the date of publication and the page the article appears on. If we were to pursue this research question further, a next step might be finding how many stories relating to fire appear on a newspaper&#39;s front page over time, or perhaps cleaning the data to reduce the number of false positives. As we have seen, however, exploring an API can be a useful first step in gathering data to tackle a research question.\u003C\u002Fp\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\nNote that in this section, we skipped an important step: finding an appropriate API in the first place. Some resources for researching APIs are available at the end of this lesson.\\n\u003C\u002Fdiv\u003E\\n\\n\u003Ch2 id=\\\"what-users-want-in-an-api\\\"\u003EWhat Users Want in an API\u003C\u002Fh2\u003E\\n\u003Cp\u003EAs we&#39;ve learned, documentation is a user&#39;s starting place when working with a new API, and well-designed URLs make it easier for users to intuitively find resources. Because they help users to quickly access information through your API, these elements—documentation and well-conceived URLs—are the \u003Cem\u003Esine qua non\u003C\u002Fem\u003E of a good API. We&#39;ll discuss these elements in greater depth later in this tutorial.\u003C\u002Fp\u003E\\n\u003Cp\u003EAs you use other APIs in your research, you&#39;ll develop a sense of what makes a good API from the perspective of a potential user. Just as strong readers often make strong writers, using APIs created by others and critically evaluating their implementation and documentation will help you better design your own APIs.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"implementing-our-api\\\"\u003EImplementing Our API\u003C\u002Fh1\u003E\\n\u003Ch2 id=\\\"overview\\\"\u003EOverview\u003C\u002Fh2\u003E\\n\u003Cp\u003EThis section will show you how to build a prototype API using Python and the Flask web framework. Our example API will take the form of a distant reading archive—a book catalog that goes beyond standard bibliographic information to include data of interest to those working on digital projects. In this case, besides title and date of publication, our API will also serve the first sentence of each book. This should be enough data to allow us to envision some potential research questions without overwhelming us as we focus on the design of our API.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe&#39;ll begin by using Flask to create a home page for our site. In this step, we&#39;ll learn the basics of how Flask works and make sure our software is configured correctly. Once we have a small Flask application working in the form of a home page, we&#39;ll iterate on this site, turning it into a functioning API.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"creating-a-basic-flask-application\\\"\u003ECreating a Basic Flask Application\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002Fflask.pocoo.org\u002F\\\"\u003EFlask\u003C\u002Fa\u003E is a web framework for Python, meaning that it provides functionality for building web applications, including managing HTTP requests and rendering templates. In this section, we will create a basic Flask application. In later sections, we&#39;ll add to this application to create our API. Don&#39;t worry if you don&#39;t understand each individual line of code yet—explanations will be forthcoming once you have this initial version of the application working.\u003C\u002Fp\u003E\\n\u003Cdiv class=\\\"alert alert-warning\\\"\u003E\\n\u003Cp\u003E\u003Cstrong\u003EWhy Flask?\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\\n\\n\u003Cp\u003EPython has a number of web frameworks that can be used to create web apps and APIs. The most well-known is Django, a framework that has a set project structure and which includes many built-in tools. This can save time and effort for experienced programmers, but can be overwhelming. Flask applications tend to be written on a blank canvas, so to speak, and so are more suited to a contained application such as our prototype API.\u003C\u002Fp\u003E\\n\u003C\u002Fdiv\u003E\\n\\n\u003Cp\u003EFirst, create a new folder on your computer that will serve as a project folder. This can be in your \u003Ccode\u003EDesktop\u003C\u002Fcode\u003E folder, but I recommend creating a dedicated \u003Ccode\u003Eprojects\u003C\u002Fcode\u003E folder for this and similar projects. This tutorial will assume that the files related to this lesson will be stored in a folder called \u003Ccode\u003Eapi\u003C\u002Fcode\u003E inside a folder named \u003Ccode\u003Eprojects\u003C\u002Fcode\u003E in your home directory. If you need help with navigation on the command line, see the \u003Ca href=\\\"\u002Flessons\u002Fintro-to-bash\\\"\u003EProgramming Historian Introduction to the Bash Command Line\u003C\u002Fa\u003E for the macOS and Linux command line or the \u003Ca href=\\\"\u002Flessons\u002Fintro-to-powershell\\\"\u003EIntroduction to the Windows Command Line with PowerShell\u003C\u002Fa\u003E for Windows.\u003C\u002Fp\u003E\\n\u003Cp\u003EIn macOS, you can directly create a an \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder inside a \u003Ccode\u003Eprojects\u003C\u002Fcode\u003E folder in your home directory with this terminal  command:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Emkdir -p ~\u002Fprojects\u002Fapi\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EOn Windows, you can create the \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder with these commands in your \u003Ccode\u003Ecmd\u003C\u002Fcode\u003E command line environment:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Emd projects\\ncd projects\\nmd api\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou can also create the \u003Ccode\u003Eprojects\u003C\u002Fcode\u003E and \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folders using your operating system&#39;s graphical user interface.\u003C\u002Fp\u003E\\n\u003Cp\u003ENext, open a text editor (such as Notepad++ or BBEdit) and enter the following code:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eimport flask\\n\\napp = flask.Flask(__name__)\\napp.config[&quot;DEBUG&quot;] = True\\n\\n\\n@app.route(&#39;\u002F&#39;, methods=[&#39;GET&#39;])\\ndef home():\\n    return &quot;&lt;h1&gt;Distant Reading Archive&lt;\u002Fh1&gt;&lt;p&gt;This site is a prototype API for distant reading of science fiction novels.&lt;\u002Fp&gt;&quot;\\n\\napp.run()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESave this code as \u003Ccode\u003Eapi.py\u003C\u002Fcode\u003E in the \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder you created for this tutorial.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"running-the-application\\\"\u003ERunning the Application\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn the command line, navigate to your \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ecd projects\u002Fapi\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou can check if you&#39;re in the correct folder by running the \u003Ccode\u003Epwd\u003C\u002Fcode\u003E command. Once you&#39;re in your project directory, run the Flask application with the command:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython api.py\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou should see output similar to this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E * Running on http:\u002F\u002F127.0.0.1:5000\u002F (Press CTRL+C to quit)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EYou may also see some lines related to debugging. This message means that Flask is running your application locally (on your computer) at that address. Follow the link above, \u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002F\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002F\u003C\u002Fa\u003E, using your web browser to see the running application:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;welcome.png&quot; caption=&quot;The home page when rendered in a browser.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003ECongratulations, you&#39;ve created a working web application!\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"what-flask-does\\\"\u003EWhat Flask Does\u003C\u002Fh2\u003E\\n\u003Cp\u003ENow that we have a homepage for our archive, let&#39;s talk about how Flask works and what the above code is doing.\u003C\u002Fp\u003E\\n\u003Cp\u003EFlask maps HTTP requests to Python functions. In this case, we&#39;ve mapped one URL path (&#39;\u003Ccode\u003E\u002F\u003C\u002Fcode\u003E&#39;) to one function, \u003Ccode\u003Ehome\u003C\u002Fcode\u003E. When we connect to the Flask server at \u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002F\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002F\u003C\u002Fa\u003E, Flask checks if there is a match between the path provided and a defined function. Since \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E, or no additional provided path, has been mapped to the \u003Ccode\u003Ehome\u003C\u002Fcode\u003E function, Flask runs the code in the function and displays the returned result in the browser. In this case, the returned result is HTML markup for a home page welcoming visitors to the site hosting our API.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe process of mapping URLs to functions is called \u003Cstrong\u003Erouting\u003C\u002Fstrong\u003E. The\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E@app.route(&#39;\u002F&#39;, methods=[&#39;GET&#39;])\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003Esyntax is the part of the program that lets Flask know that this function, \u003Ccode\u003Ehome\u003C\u002Fcode\u003E, should be mapped to the path \u003Ccode\u003E\u002F\u003C\u002Fcode\u003E. The \u003Ccode\u003Emethods\u003C\u002Fcode\u003E list (\u003Ccode\u003Emethods=[&#39;GET&#39;]\u003C\u002Fcode\u003E) is a keyword argument that lets Flask know what kind of HTTP requests are allowed. We&#39;ll only be using \u003Ccode\u003EGET\u003C\u002Fcode\u003E requests in this tutorial, but many web applications need to use both \u003Ccode\u003EGET\u003C\u002Fcode\u003E requests (to send data from the application to the user) and \u003Ccode\u003EPOST\u003C\u002Fcode\u003E requests (to receive data from a user).\u003C\u002Fp\u003E\\n\u003Cp\u003EBelow are brief explanations of the other components of the application:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eimport flask\u003C\u002Fcode\u003E — Imports the Flask library, making the code available to the rest of the application.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eapp = flask.Flask(__name__)\u003C\u002Fcode\u003E — Creates the Flask application object, which contains data about the application and also methods (object functions) that tell the application to do certain actions. The last line, \u003Ccode\u003Eapp.run()\u003C\u002Fcode\u003E, is one such method.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eapp.config[&quot;DEBUG&quot;] = True\u003C\u002Fcode\u003E — Starts the debugger. With this line, if your code is malformed, you&#39;ll see an error when you visit your app. Otherwise you&#39;ll only see a generic message such as \u003Ccode\u003EBad Gateway\u003C\u002Fcode\u003E in the browser when there&#39;s a problem with your code.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eapp.run()\u003C\u002Fcode\u003E — A method that runs the application server.\u003C\u002Fp\u003E\\n\u003Cp\u003EWhile it&#39;s useful to have a familiarity with what&#39;s going on in the script, don&#39;t worry if you don&#39;t understand precisely what every element is doing at this stage. If you understand the general outline of how this portion works, the details of how Flask renders pages are likely to become more understandable as we continue to develop our API.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"creating-the-api\\\"\u003ECreating the API\u003C\u002Fh2\u003E\\n\u003Cp\u003ENow that we have a running Flask application and know a little about what Flask does, we&#39;re finally ready to implement a small API with data that we&#39;ll define right in our application.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe&#39;ll be adding our data as a list of Python dictionaries. Dictionaries in Python group pairs of keys and values, like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E{\\n    &#39;key&#39;: &#39;value&#39;,\\n    &#39;key&#39;: &#39;value&#39;\\n}\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe key identifies the type of information represented, such as \u003Ccode\u003Etitle\u003C\u002Fcode\u003E or \u003Ccode\u003Eid\u003C\u002Fcode\u003E. The value is the actual data. For example, a short telephone book might take this format:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E[\\n    {\\n        &#39;name&#39;: &#39;Alexander Graham Bell&#39;,\\n        &#39;number&#39;: &#39;1-333-444-5555&#39;\\n    },\\n    {\\n        &#39;name&#39;: &#39;Thomas A. Watson&#39;,\\n        &#39;number&#39;: &#39;1-444-555-6666&#39;\\n    }\\n]\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe above phone book is a list of two dictionaries. Each dictionary is a phone book entry consisting of two keys, \u003Ccode\u003Ename\u003C\u002Fcode\u003E and \u003Ccode\u003Enumber\u003C\u002Fcode\u003E, each paired with a value that provides the actual information.\u003C\u002Fp\u003E\\n\u003Cp\u003ELet&#39;s add some data (entries on three science fiction novels) as a list of dictionaries. Each dictionary will contain ID number, title, author, first sentence, and year of publication for each book. Finally, we&#39;ll add a new function: a route that will allow a visitor to access our data.\u003C\u002Fp\u003E\\n\u003Cp\u003EReplace our previous code in \u003Ccode\u003Eapi.py\u003C\u002Fcode\u003E with the code below:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eimport flask\\nfrom flask import request, jsonify\\n\\napp = flask.Flask(__name__)\\napp.config[&quot;DEBUG&quot;] = True\\n\\n# Create some test data for our catalog in the form of a list of dictionaries.\\nbooks = [\\n    {&#39;id&#39;: 0,\\n     &#39;title&#39;: &#39;A Fire Upon the Deep&#39;,\\n     &#39;author&#39;: &#39;Vernor Vinge&#39;,\\n     &#39;first_sentence&#39;: &#39;The coldsleep itself was dreamless.&#39;,\\n     &#39;year_published&#39;: &#39;1992&#39;},\\n    {&#39;id&#39;: 1,\\n     &#39;title&#39;: &#39;The Ones Who Walk Away From Omelas&#39;,\\n     &#39;author&#39;: &#39;Ursula K. Le Guin&#39;,\\n     &#39;first_sentence&#39;: &#39;With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.&#39;,\\n     &#39;published&#39;: &#39;1973&#39;},\\n    {&#39;id&#39;: 2,\\n     &#39;title&#39;: &#39;Dhalgren&#39;,\\n     &#39;author&#39;: &#39;Samuel R. Delany&#39;,\\n     &#39;first_sentence&#39;: &#39;to wound the autumnal city.&#39;,\\n     &#39;published&#39;: &#39;1975&#39;}\\n]\\n\\n\\n@app.route(&#39;\u002F&#39;, methods=[&#39;GET&#39;])\\ndef home():\\n    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;\u002Fh1&gt;\\n&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;\u002Fp&gt;&#39;&#39;&#39;\\n\\n\\n# A route to return all of the available entries in our catalog.\\n@app.route(&#39;\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall&#39;, methods=[&#39;GET&#39;])\\ndef api_all():\\n    return jsonify(books)\\n\\napp.run()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ERun the code (navigate to your \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder in the command line and enter \u003Ccode\u003Epython api.py\u003C\u002Fcode\u003E). Once the server is running, visit our route URL to view the data in the catalog:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EYou should see JSON output for the three entries in our test catalog. Flask provides us with a \u003Ccode\u003Ejsonify\u003C\u002Fcode\u003E function that allows us to convert lists and dictionaries to JSON format. In the route we created, our book entries are converted from a list of Python dictionaries to JSON before being returned to a user.\u003C\u002Fp\u003E\\n\u003Cp\u003EAt this point, you&#39;ve created a working, if limited, API. In the next section, we&#39;ll allow users to find books via more specific data, such as an entry&#39;s ID.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"finding-specific-resources\\\"\u003EFinding Specific Resources\u003C\u002Fh2\u003E\\n\u003Cp\u003ERight now, users can only view our entire database—they can&#39;t filter or find specific resources. While this isn&#39;t a problem with our test catalog, this will quickly become less useful as we add data. In this section, we&#39;ll add a function that allows users to filter their returned results using a more specific request.\u003C\u002Fp\u003E\\n\u003Cp\u003EBelow is the code for our new application with filtering capability. As before, we&#39;ll examine the code more carefully once you have it running.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eimport flask\\nfrom flask import request, jsonify\\n\\napp = flask.Flask(__name__)\\napp.config[&quot;DEBUG&quot;] = True\\n\\n# Create some test data for our catalog in the form of a list of dictionaries.\\nbooks = [\\n    {&#39;id&#39;: 0,\\n     &#39;title&#39;: &#39;A Fire Upon the Deep&#39;,\\n     &#39;author&#39;: &#39;Vernor Vinge&#39;,\\n     &#39;first_sentence&#39;: &#39;The coldsleep itself was dreamless.&#39;,\\n     &#39;year_published&#39;: &#39;1992&#39;},\\n    {&#39;id&#39;: 1,\\n     &#39;title&#39;: &#39;The Ones Who Walk Away From Omelas&#39;,\\n     &#39;author&#39;: &#39;Ursula K. Le Guin&#39;,\\n     &#39;first_sentence&#39;: &#39;With a clamor of bells that set the swallows soaring, the Festival of Summer came to the city Omelas, bright-towered by the sea.&#39;,\\n     &#39;published&#39;: &#39;1973&#39;},\\n    {&#39;id&#39;: 2,\\n     &#39;title&#39;: &#39;Dhalgren&#39;,\\n     &#39;author&#39;: &#39;Samuel R. Delany&#39;,\\n     &#39;first_sentence&#39;: &#39;to wound the autumnal city.&#39;,\\n     &#39;published&#39;: &#39;1975&#39;}\\n]\\n\\n\\n@app.route(&#39;\u002F&#39;, methods=[&#39;GET&#39;])\\ndef home():\\n    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;\u002Fh1&gt;\\n&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;\u002Fp&gt;&#39;&#39;&#39;\\n\\n\\n@app.route(&#39;\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall&#39;, methods=[&#39;GET&#39;])\\ndef api_all():\\n    return jsonify(books)\\n\\n\\n@app.route(&#39;\u002Fapi\u002Fv1\u002Fresources\u002Fbooks&#39;, methods=[&#39;GET&#39;])\\ndef api_id():\\n    # Check if an ID was provided as part of the URL.\\n    # If ID is provided, assign it to a variable.\\n    # If no ID is provided, display an error in the browser.\\n    if &#39;id&#39; in request.args:\\n        id = int(request.args[&#39;id&#39;])\\n    else:\\n        return &quot;Error: No id field provided. Please specify an id.&quot;\\n\\n    # Create an empty list for our results\\n    results = []\\n\\n    # Loop through the data and match results that fit the requested ID.\\n    # IDs are unique, but other fields might return many results\\n    for book in books:\\n        if book[&#39;id&#39;] == id:\\n            results.append(book)\\n\\n    # Use the jsonify function from Flask to convert our list of\\n    # Python dictionaries to the JSON format.\\n    return jsonify(results)\\n\\napp.run()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EOnce you&#39;ve updated your API with the \u003Ccode\u003Eapi_id\u003C\u002Fcode\u003E function, run your code as before (\u003Ccode\u003Epython api.py\u003C\u002Fcode\u003E from your \u003Ccode\u003Eapi\u003C\u002Fcode\u003E directory) and visit the below URLs to test the new filtering capability:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=0\\\"\u003E127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=0\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=1\\\"\u003E127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=1\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=2\\\"\u003E127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=2\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=3\\\"\u003E127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?id=3\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EEach of these should return a different entry, except for the last, which should return an empty list: \u003Ccode\u003E[]\u003C\u002Fcode\u003E, since there is no book for which the id value is 3. (Counting in programming typically starts from 0, so id=3 would be a request for a nonexistent fourth item.) In the next section, we&#39;ll explore our updated API in more detail.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"understanding-our-updated-api\\\"\u003EUnderstanding Our Updated API\u003C\u002Fh2\u003E\\n\u003Cp\u003EIn this code, we first create a new function, called \u003Ccode\u003Eapi_id\u003C\u002Fcode\u003E, with the \u003Ccode\u003E@app.route\u003C\u002Fcode\u003E syntax that maps the function to the path \u003Ccode\u003E\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u003C\u002Fcode\u003E. That means that this function will run when we access \u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u003C\u002Fa\u003E. (Note that accessing this link without providing an ID will give the error message we provided in the code: \u003Ccode\u003EError: No id field provided. Please specify an id.\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\\n\u003Cp\u003EInside our function, we do two things:\u003C\u002Fp\u003E\\n\u003Cp\u003EFirst, examine the provided URL for an id and select the books that match that id. The id must be provided like this: \u003Ccode\u003E?id=0\u003C\u002Fcode\u003E. Data passed through URLs like this (after the \u003Ccode\u003E?\u003C\u002Fcode\u003E) are called \u003Cstrong\u003Equery parameters\u003C\u002Fstrong\u003E—we&#39;ve seen them before when we worked with the Chronicling America API. They&#39;re a feature of HTTP used for filtering for specific kinds of data.\u003C\u002Fp\u003E\\n\u003Cp\u003EThis part of the code determines if there is a query parameter, like \u003Ccode\u003E?id=0\u003C\u002Fcode\u003E, and then assigns the provided ID to a variable.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E    if &#39;id&#39; in request.args:\\n        id = int(request.args[&#39;id&#39;])\\n    else:\\n        return &quot;Error: No id field provided. Please specify an id.&quot;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThen this section moves through our test catalog of books, matches those books that have the provided ID, and appends them to the list that will be returned to the user:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E    for book in books:\\n        if book[&#39;id&#39;] == id:\\n            results.append(book)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFinally, the \u003Ccode\u003Ereturn jsonify(results)\u003C\u002Fcode\u003E line takes the list of results and renders them in the browser as JSON.\u003C\u002Fp\u003E\\n\u003Cp\u003EIf you&#39;ve gotten this far, you&#39;ve created an actual API. Celebrate! At the end of this lesson, you&#39;ll be exposed to a somewhat more complex API that uses a database, but most of the principles and patterns we&#39;ve used so far will still apply. In the next section, we&#39;ll discuss some guidelines for creating a well-designed API that others will actually want to use. In the last section of the tutorial, we&#39;ll apply these principles to a version of our API that pulls in results from a database.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"api-design-principles\\\"\u003EAPI Design Principles\u003C\u002Fh1\u003E\\n\u003Cp\u003EThus far, we&#39;ve created a working API with test data that we&#39;ve provided right in our application. Our next version of our API will pull in data from a database before providing it to a user. It will also take additional query parameters, allowing users to filter by fields other than ID.\u003C\u002Fp\u003E\\n\u003Cp\u003EBefore building more functionality into our application, let&#39;s reflect on some of the API design decisions that we&#39;ve made so far. Two aspects of a good API are usability and maintainability, and as we build more functionality into our API, we&#39;ll be keeping many of the following considerations in mind.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"designing-requests\\\"\u003EDesigning Requests\u003C\u002Fh2\u003E\\n\u003Cp\u003EThe prevailing design philosophy of modern APIs is called REST. For our purposes, the most important thing about REST is that it&#39;s based on the four methods defined by the HTTP protocol: POST, GET, PUT, and DELETE. These correspond to the four traditional actions performed on data in a database: CREATE, READ, UPDATE, and DELETE. In this tutorial, we&#39;ll only be concerned with GET requests, which correspond to reading from a database.\u003C\u002Fp\u003E\\n\u003Cp\u003EBecause HTTP requests are so integral to using a REST API, many design principles revolve around how requests should be formatted. We&#39;ve already created one HTTP request, which returns all books provided in our sample data. To understand the considerations that go into formatting this request, let&#39;s first consider a weak or poorly-designed example of an API endpoint:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fapi.example.com\u002Fgetbook\u002F10\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe formatting of this request has a number of issues. The first is semantic—in a REST API, our verbs are typically \u003Ccode\u003EGET\u003C\u002Fcode\u003E, \u003Ccode\u003EPOST\u003C\u002Fcode\u003E, \u003Ccode\u003EPUT\u003C\u002Fcode\u003E, or \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E, and are determined by the request method rather than in the request URL. That means that the word &quot;get&quot; should not appear in our request, since &quot;get&quot; is implied by the fact that we&#39;re using a HTTP GET method. In addition, resource collections such as \u003Ccode\u003Ebooks\u003C\u002Fcode\u003E or \u003Ccode\u003Eusers\u003C\u002Fcode\u003E should be denoted with plural nouns. This makes it clear when an API is referring to a collection (\u003Ccode\u003Ebooks\u003C\u002Fcode\u003E) or an entry (\u003Ccode\u003Ebook\u003C\u002Fcode\u003E). Incorporating these principles, our API would look like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fapi.example.com\u002Fbooks\u002F10\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe above request uses part of the path (\u003Ccode\u003E\u002F10\u003C\u002Fcode\u003E) to provide the ID. While this is not an uncommon approach, it&#39;s somewhat inflexible—with URLs constructed in this manner, you can generally only filter by one field at a time. Query parameters allow for filtering by multiple database fields and make more sense when providing &quot;optional&quot; data, such as an output format:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fapi.example.com\u002Fbooks?author=Ursula+K.+Le Guin&amp;published=1969&amp;output=xml\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWhen designing how requests to your API should be structured, it also makes sense to plan for future additions. Even if the current version of your API serves information on only one type of resource—\u003Ccode\u003Ebooks\u003C\u002Fcode\u003E, for example—it makes sense to plan as if you might add other resources or non-resource functionality to your API in the future:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttp:\u002F\u002Fapi.example.com\u002Fresources\u002Fbooks?id=10\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAdding an extra segment on your path  such as &quot;resources&quot; or &quot;entries&quot; gives you the option to allow users to search across all resources available, making it easier for you to later support requests such as these:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttps:\u002F\u002Fapi.example.com\u002Fv1\u002Fresources\u002Fimages?id=10\\nhttps:\u002F\u002Fapi.example.com\u002Fv1\u002Fresources\u002Fall\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EAnother way to plan for your API&#39;s future is to add a version number to the path. This means that, should you have to redesign your API, you can continue to support the old version of the API under the old version number while releasing, for example, a second version (\u003Ccode\u003Ev2\u003C\u002Fcode\u003E) with improved or different functionality. This way, applications and scripts built using the old version of your API won&#39;t cease to function after your upgrade.\u003C\u002Fp\u003E\\n\u003Cp\u003EAfter incorporating these design improvements, a request to our API might look like this:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ehttps:\u002F\u002Fapi.example.com\u002Fv1\u002Fresources\u002Fbooks?id=10\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Ch2 id=\\\"documentation-and-examples\\\"\u003EDocumentation and Examples\u003C\u002Fh2\u003E\\n\u003Cp\u003EWithout documentation, even the best-designed API will be unusable. Your API should have documentation describing the resources or functionality available through your API that also provides concrete working examples of request URLs or code for your API. You should have a section for each resource that describes which fields, such as \u003Ccode\u003Eid\u003C\u002Fcode\u003E or \u003Ccode\u003Etitle\u003C\u002Fcode\u003E, it accepts. Each section should have an example in the form of a sample HTTP request or block of code.\u003C\u002Fp\u003E\\n\u003Cp\u003EA fairly common practice in documenting APIs is to provide annotations in your code that are then automatically collated into documentation using a tool such as \u003Ca href=\\\"http:\u002F\u002Fwww.doxygen.org\u002F\\\"\u003EDoxygen\u003C\u002Fa\u003E or \u003Ca href=\\\"http:\u002F\u002Fwww.sphinx-doc.org\u002Fen\u002Fstable\u002F\\\"\u003ESphinx\u003C\u002Fa\u003E. These tools create documentation from \u003Cstrong\u003Edocstrings\u003C\u002Fstrong\u003E—comments you make on your function definitions. While this kind of documentation is a good idea, you shouldn&#39;t consider your job done if you&#39;ve only documented your API to this level. Instead, try to imagine yourself as a potential user of your API and provide working examples. In an ideal world, you would have three kinds of documentation for your API: a reference that details each route and its behavior, a guide that explains the reference in prose, and at least one or two tutorials that explain every step in detail.\u003C\u002Fp\u003E\\n\u003Cp\u003EFor inspiration on how to approach API documentation, see the \u003Ca href=\\\"http:\u002F\u002Fapi.repo.nypl.org\u002F\\\"\u003ENew York Public Library Digital Collections API\u003C\u002Fa\u003E, which sets a standard of documentation achievable for many academic projects. For an extensively documented (though sometimes overwhelming) API, see the \u003Ca href=\\\"https:\u002F\u002Fwww.mediawiki.org\u002Fwiki\u002FAPI:Main_page\\\"\u003EMediaWiki Action API\u003C\u002Fa\u003E, which provides documentation to users who pass partial queries to the API. (In our example above, we returned an error on a partial query.) For other professionally maintained API documentation examples, consider the \u003Ca href=\\\"https:\u002F\u002Fdatahelpdesk.worldbank.org\u002Fknowledgebase\u002Farticles\u002F889392-api-documentation\\\"\u003EWorld Bank API\u003C\u002Fa\u003E, the various \u003Ca href=\\\"https:\u002F\u002Fdeveloper.nytimes.com\u002F\\\"\u003ENew York Times APIs\u003C\u002Fa\u003E, or the \u003Ca href=\\\"https:\u002F\u002Fpro.europeana.eu\u002Fresources\u002Fapis\\\"\u003EEuropeana Pro API\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"connecting-our-api-to-a-database\\\"\u003EConnecting Our API to a Database\u003C\u002Fh1\u003E\\n\u003Cp\u003EThis last example of our Distant Reading Archive API pulls in data from a database, implements error handling, and can filter books by publication date. The database used is SQLite, a lightweight database engine that is supported in Python by default. SQLite files typically end with the \u003Ccode\u003E.db\u003C\u002Fcode\u003E file extension.\u003C\u002Fp\u003E\\n\u003Cp\u003EBefore we modify our code, first \u003Ca href=\\\"\u002Fassets\u002Fcreating-apis-with-python-and-flask\u002Fbooks.db\\\"\u003Edownload the example database from this location\u003C\u002Fa\u003E and copy the file to your \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder using your graphical user interface. The final version of our API will query this database when returning results to users.\u003C\u002Fp\u003E\\n\u003Cp\u003ECopy the below code into your text editor. As before, we&#39;ll examine the code more closely once you have it running.\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Eimport flask\\nfrom flask import request, jsonify\\nimport sqlite3\\n\\napp = flask.Flask(__name__)\\napp.config[&quot;DEBUG&quot;] = True\\n\\ndef dict_factory(cursor, row):\\n    d = {}\\n    for idx, col in enumerate(cursor.description):\\n        d[col[0]] = row[idx]\\n    return d\\n\\n\\n@app.route(&#39;\u002F&#39;, methods=[&#39;GET&#39;])\\ndef home():\\n    return &#39;&#39;&#39;&lt;h1&gt;Distant Reading Archive&lt;\u002Fh1&gt;\\n&lt;p&gt;A prototype API for distant reading of science fiction novels.&lt;\u002Fp&gt;&#39;&#39;&#39;\\n\\n\\n@app.route(&#39;\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall&#39;, methods=[&#39;GET&#39;])\\ndef api_all():\\n    conn = sqlite3.connect(&#39;books.db&#39;)\\n    conn.row_factory = dict_factory\\n    cur = conn.cursor()\\n    all_books = cur.execute(&#39;SELECT * FROM books;&#39;).fetchall()\\n\\n    return jsonify(all_books)\\n\\n\\n\\n@app.errorhandler(404)\\ndef page_not_found(e):\\n    return &quot;&lt;h1&gt;404&lt;\u002Fh1&gt;&lt;p&gt;The resource could not be found.&lt;\u002Fp&gt;&quot;, 404\\n\\n\\n@app.route(&#39;\u002Fapi\u002Fv1\u002Fresources\u002Fbooks&#39;, methods=[&#39;GET&#39;])\\ndef api_filter():\\n    query_parameters = request.args\\n\\n    id = query_parameters.get(&#39;id&#39;)\\n    published = query_parameters.get(&#39;published&#39;)\\n    author = query_parameters.get(&#39;author&#39;)\\n\\n    query = &quot;SELECT * FROM books WHERE&quot;\\n    to_filter = []\\n\\n    if id:\\n        query += &#39; id=? AND&#39;\\n        to_filter.append(id)\\n    if published:\\n        query += &#39; published=? AND&#39;\\n        to_filter.append(published)\\n    if author:\\n        query += &#39; author=? AND&#39;\\n        to_filter.append(author)\\n    if not (id or published or author):\\n        return page_not_found(404)\\n\\n    query = query[:-4] + &#39;;&#39;\\n\\n    conn = sqlite3.connect(&#39;books.db&#39;)\\n    conn.row_factory = dict_factory\\n    cur = conn.cursor()\\n\\n    results = cur.execute(query, to_filter).fetchall()\\n\\n    return jsonify(results)\\n\\napp.run()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ESave the code as \u003Ccode\u003Eapi_final.py\u003C\u002Fcode\u003E in your \u003Ccode\u003Eapi\u003C\u002Fcode\u003E folder and run it by navigating to your project folder in the terminal and entering the command:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Epython api_final.py\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ENote that if a previous version of the code is still running, you will first need to end that process by pressing \u003Ccode\u003EControl-C\u003C\u002Fcode\u003E before executing the new code. Once this example is running, try out the filtering functionality with these HTTP requests:\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks\u002Fall\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?author=Connie+Willis\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?author=Connie+Willis\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?author=Connie+Willis&amp;published=1993\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?author=Connie+Willis&amp;published=1999\u003C\u002Fa\u003E\\n\u003Ca href=\\\"http:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?published=2010\\\"\u003Ehttp:\u002F\u002F127.0.0.1:5000\u002Fapi\u002Fv1\u002Fresources\u002Fbooks?published=2010\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003EThe database downloaded for this lesson has 67 entries, one for each of the winners of the Hugo Award for best science fiction novel between 1953 and 2014 (avoiding the voting controversy of 2015). The data set includes the novel&#39;s title, author, year of publication, and first sentence. Our API allows users to filter by three fields: \u003Ccode\u003Eid\u003C\u002Fcode\u003E, \u003Ccode\u003Epublished\u003C\u002Fcode\u003E (year of publication), and \u003Ccode\u003Eauthor\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe first request returns all entries in the database, similar to the \u003Ccode\u003E\u002Fall\u003C\u002Fcode\u003E request we implemented for the last version of our API. The second request returns all books by the author Connie Willis (\u003Ccode\u003E?author=Connie+Willis\u003C\u002Fcode\u003E). Note that, within a query parameter, spaces between words are denoted with a \u003Ccode\u003E+\u003C\u002Fcode\u003E sign, hence \u003Ccode\u003EConnie+Willis\u003C\u002Fcode\u003E. The third request filters by two fields—author and year of publication. Instead of the three books returned by requesting \u003Ccode\u003E?author=Connie+Willis\u003C\u002Fcode\u003E, this request returns only the entry to \u003Cem\u003EThe Doomsday Book\u003C\u002Fem\u003E, published in 1993. The last request returns all Hugo winners from the year 2010 (note that, in some years, more than one Hugo is awarded).\u003C\u002Fp\u003E\\n\u003Cp\u003EAs we can see this version of our API serves a larger number of results, results that are stored in an SQLite database (\u003Ccode\u003Ebooks.db\u003C\u002Fcode\u003E). When our user requests an entry or set of entries, our API pulls that information from the database by building and executing an SQL query. This iteration of our API also allows for filtering by more than one field. We&#39;ll discuss potential uses for this functionality after examining our code more closely.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"understanding-our-database-powered-api\\\"\u003EUnderstanding Our Database-Powered API\u003C\u002Fh2\u003E\\n\u003Cp\u003ERelational databases allow for the storage and retrieval of data, which is stored in tables. Tables are similar to spread sheets in that they have columns and rows—columns indicate what the data representes, such as &quot;title&quot; or &quot;date.&quot; Rows represent individual entries, which could be books, users, transactions, or any other kind of entity.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe database we&#39;re working with has five columns \u003Ccode\u003Eid\u003C\u002Fcode\u003E, \u003Ccode\u003Epublished\u003C\u002Fcode\u003E, \u003Ccode\u003Eauthor\u003C\u002Fcode\u003E, \u003Ccode\u003Etitle\u003C\u002Fcode\u003E, and \u003Ccode\u003Efirst_sentence\u003C\u002Fcode\u003E. Each row represents one book that won the Hugo award in the year under the \u003Ccode\u003Epublished\u003C\u002Fcode\u003E heading, and the text of which begins with the sentence in the \u003Ccode\u003Efirst_sentence\u003C\u002Fcode\u003E column.\u003C\u002Fp\u003E\\n\u003Cp\u003ERather than use test data defined in the application, our \u003Ccode\u003Eapi_all\u003C\u002Fcode\u003E function pulls in data from our Hugo database:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003Edef api_all():\\n    conn = sqlite3.connect(&#39;books.db&#39;)\\n    conn.row_factory = dict_factory\\n    cur = conn.cursor()\\n    all_books = cur.execute(&#39;SELECT * FROM books;&#39;).fetchall()\\n\\n    return jsonify(all_books)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFirst, we connect to the database using our \u003Ccode\u003Esqlite3\u003C\u002Fcode\u003E library. An object representing the connection to the database is bound to the \u003Ccode\u003Econn\u003C\u002Fcode\u003E variable. The \u003Ccode\u003Econn.row_factory = dict_factory\u003C\u002Fcode\u003E line lets the connection object know to use the \u003Ccode\u003Edict_factory\u003C\u002Fcode\u003E function we&#39;ve defined, which returns items from the database as dictionaries rather than lists—these work better when we output them to JSON. We then create a cursor object (\u003Ccode\u003Ecur = conn.cursor()\u003C\u002Fcode\u003E), which is the object that actually moves through the database to pull our data. Finally, we execute an SQL query with the \u003Ccode\u003Ecur.execute\u003C\u002Fcode\u003E method to pull out all available data (\u003Ccode\u003E*\u003C\u002Fcode\u003E) from the \u003Ccode\u003Ebooks\u003C\u002Fcode\u003E table of our database. At the end of our function, this data is returned as JSON: \u003Ccode\u003Ejsonify(all_books)\u003C\u002Fcode\u003E. Note that our other function that returns data, \u003Ccode\u003Eapi_filter\u003C\u002Fcode\u003E, will use a similar approach to pull data from the database.\u003C\u002Fp\u003E\\n\u003Cp\u003EThe purpose of our \u003Ccode\u003Epage_not_found\u003C\u002Fcode\u003E function is to create an error page seen by the user if the user encounters an error or inputs a route that hasn&#39;t been defined:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E@app.errorhandler(404)\\ndef page_not_found(e):\\n    return &quot;&lt;h1&gt;404&lt;\u002Fh1&gt;&lt;p&gt;The resource could not be found.&lt;\u002Fp&gt;&quot;, 404\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIn HTML responses, the code \u003Ccode\u003E200\u003C\u002Fcode\u003E means &quot;OK&quot;(the expected data transferred), while the code \u003Ccode\u003E404\u003C\u002Fcode\u003E means &quot;Not Found&quot; (there was no resource available at the URL given). This function allows us to return 404 pages when something goes wrong in the application.\u003C\u002Fp\u003E\\n\u003Cp\u003EOur \u003Ccode\u003Eapi_filter\u003C\u002Fcode\u003E function is an improvement on our previous \u003Ccode\u003Eapi_id\u003C\u002Fcode\u003E function that returns a book based on its ID. This new function allows for filtering by three different fields: \u003Ccode\u003Eid\u003C\u002Fcode\u003E, \u003Ccode\u003Epublished\u003C\u002Fcode\u003E, and \u003Ccode\u003Eauthor\u003C\u002Fcode\u003E. The function first grabs all the query parameters provided in the URL (remember, query parameters are the part of the URL that follows the \u003Ccode\u003E?\u003C\u002Fcode\u003E, like \u003Ccode\u003E?id=10\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Equery_parameters = request.args\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIt then pulls the supported parameters \u003Ccode\u003Eid\u003C\u002Fcode\u003E, \u003Ccode\u003Epublished\u003C\u002Fcode\u003E, and \u003Ccode\u003Eauthor\u003C\u002Fcode\u003E and binds them to appropriate variables:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Eid = query_parameters.get(&#39;id&#39;)\\npublished = query_parameters.get(&#39;published&#39;)\\nauthor = query_parameters.get(&#39;author&#39;)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThe next segment begins to build an SQL query that will be used to find the requested information in the database. SQL queries used to find data in a database take this form:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003E`SELECT &lt;columns&gt; FROM &lt;table&gt; WHERE &lt;column=match&gt; AND &lt;column=match&gt;;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo get the correct data, we need to build both an SQL query that looks like the above and a list with the filters that will be matched. Combined, the query and the the filters provided by the user will allow us to pull the correct books from our database.\u003C\u002Fp\u003E\\n\u003Cp\u003EWe begin to define both the query and the filter list:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Equery = &quot;SELECT * FROM books WHERE&quot;\\nto_filter = []\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EThen, if \u003Ccode\u003Eid\u003C\u002Fcode\u003E, \u003Ccode\u003Epublished\u003C\u002Fcode\u003E, or \u003Ccode\u003Eauthor\u003C\u002Fcode\u003E were provided as query parameters, we add them to both the query and the filter list:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E    if id:\\n        query += &#39; id=? AND&#39;\\n        to_filter.append(id)\\n    if published:\\n        query += &#39; published=? AND&#39;\\n        to_filter.append(published)\\n    if author:\\n        query += &#39; author=? AND&#39;\\n        to_filter.append(author)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EIf the user has provided none of these query parameters, we have nothing to show, so we send them to the &quot;404 Not Found&quot; page:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E    if not (id or published or author):\\n        return page_not_found(404)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003ETo perfect our query, we remove the trailing \u003Ccode\u003E AND\u003C\u002Fcode\u003E and cap the query with the \u003Ccode\u003E;\u003C\u002Fcode\u003E required at the end of all SQL statements:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-python\\\"\u003E    query = query[:-4] + &#39;;&#39;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFinally, we connect to our database as in our \u003Ccode\u003Eapi_all\u003C\u002Fcode\u003E function, then execute the query we&#39;ve built using our filter list:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Econn = sqlite3.connect(&#39;books.db&#39;)\\nconn.row_factory = dict_factory\\ncur = conn.cursor()\\n\\nresults = cur.execute(query, to_filter).fetchall()\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EFinally, we return the results of our executed SQL query as JSON to the user:\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode\u003Ereturn jsonify(results)\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EWhew! When all is said and done, this section of code reads query parameters provided by the user, builds an SQL query based on those parameters, executes that query to find matching books in the database, and returns those matches as JSON to the user. This section of code makes our API&#39;s filtering capability considerably more sophisticated—users can now find books by, for example, Ursula K. Le Guin that were published in 1975 or all books in the database published in 2010.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"our-api-in-practice\\\"\u003EOur API in Practice\u003C\u002Fh2\u003E\\n\u003Cp\u003ENow that we have implemented our Distant Reading API, let&#39;s consider how it might be of use in digital projects and in research.\u003C\u002Fp\u003E\\n\u003Cp\u003EOne of the advantages of providing data through an API, as opposed to providing some kind of downloadable database or file for users, is that, as new data or additional resources are added, they become immediately available to projects built using the API. Imagine that we make our API publicly available, and a user creates a visualization that plots the length of a novel&#39;s first sentence in characters against its year of publication:\u003C\u002Fp\u003E\\n\u003Cp\u003E{% include figure.html filename=&quot;hugo.png&quot; caption=&quot;Scatterplot of first sentence length against date of publication.&quot; %}\u003C\u002Fp\u003E\\n\u003Cp\u003EAs new Hugo winners were added to the database, the script that generated this visualization would immediately be able to use the new information. If the visualization were created in D3 or another web-based utility, this plot would actually reflect additional data added to the book archive as soon as the archive was updated—that is, in real time. As additional data accrued, we might, for example, learn if John Scalzi&#39;s unusually lengthy opening to his 2013 \u003Cem\u003ERed Shirts\u003C\u002Fem\u003E was an aberration or the continuation of a longer trend toward wordiness in science fiction. Conversely, if your API were to change its URL structure or cease to function, applications based on it will no longer work. Remember that, when creating an API, you are assuming some responsibility for the applications that others may build with it.\u003C\u002Fp\u003E\\n\u003Cp\u003EA strong API can be considered the backbone of a potentially limitless number of projects or avenues of research. Though the above example takes the form of a visualization of the limited amount of data we&#39;ve provided in our Distant Reading Archive, a project based on this API might just as easily take the form of a Twitterbot that shares first sentences (learn how to make one with \u003Ca href=\\\"\u002Flessons\u002Fintro-to-twitterbots\\\"\u003Ethis\u003C\u002Fa\u003E Programming Historian lesson) or a library webpage that displays book openings and year of publication alongside other book metadata. In many cases, it makes sense to first create an API interface to your core data or functionality before extrapolating on it to create a visualization, application, or website. Not only does it make your work accessible to researchers working on other projects, but it often leads to a more comprehensible and maintainable project.\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"resources\\\"\u003EResources\u003C\u002Fh1\u003E\\n\u003Cp\u003EThe below resources provide information on useful APIs for researchers in the humanities and social sciences as well as further reading on API concepts.\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"apis-for-humanities-researchers\\\"\u003EAPIs for Humanities Researchers\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002Fchroniclingamerica.loc.gov\u002F\\\"\u003EChronicling America (Library Of Congress)\u003C\u002Fa\u003E - A digitized collection of American newspaper articles from the 18th to the 20th century.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fcore.ac.uk\u002F\\\"\u003EConnecting Repositories (CORE)\u003C\u002Fa\u003E - A collection of open access articles from various sources hosted by the Open University.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fdiggingintodata.org\u002Frepositories\u002Fenglish-broadside-ballad-archive-ebba\\\"\u003EEnglish Broadside Ballad Archive (EBBA)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"http:\u002F\u002Fhds.essex.ac.uk\u002F\\\"\u003EHistory Data Service (HDS)\u003C\u002Fa\u003E - A collection of data from a wide variety of historical sources.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fpro.europeana.eu\u002F\\\"\u003EEuropeana\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fdiggingintodata.org\u002Frepositories\\\"\u003EDigging into Data API List\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Ch2 id=\\\"api-resources\\\"\u003EAPI Resources\u003C\u002Fh2\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fdoepud.co.uk\u002Fblog\u002Fanatomy-of-a-url\\\"\u003EAnatomy of a URL\u003C\u002Fa\u003E - Explains the different sections of a URL (protocol, domain, path, and so on) in greater detail.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fwww.ics.uci.edu\u002F~fielding\u002Fpubs\u002Fdissertation\u002Ftop.htm\\\"\u003EOriginal Paper on REST\u003C\u002Fa\u003E  - PhD thesis by Roy Thomas Fielding that introduced the concepts behind the REST philosophy of API design.\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ca href=\\\"https:\u002F\u002Fblog.miguelgrinberg.com\u002Fpost\u002Fthe-flask-mega-tutorial-part-i-hello-world\\\"\u003EThe Flask Mega Tutorial\u003C\u002Fa\u003E - The most well-known tutorial for learning the Flask web framework.\u003C\u002Fp\u003E\\n\"}"}</script></div>
	</body>
</html>
